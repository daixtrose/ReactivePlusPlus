<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ReactivePlusPlus: Utility Operators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ReactivePlusPlus
   </div>
   <div id="projectbrief">One more implementation of ReactiveX approach in C++ with care about performance and templates in mind</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__utility__operators.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Utility Operators<div class="ingroups"><a class="el" href="group__rpp.html">RPP</a> &raquo; <a class="el" href="group__operators.html">Operators</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Utility operators are operators that provide some extra functionality without changing of original values, but changing of behaviour.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaaf883140cd425aa10c6a314eb014fb9b"><td class="memTemplParams" colspan="2">template&lt;schedulers::constraint::scheduler TScheduler&gt; <br />
requires is_header_included&lt;delay_tag, TScheduler&gt;</td></tr>
<tr class="memitem:gaaf883140cd425aa10c6a314eb014fb9b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#gaaf883140cd425aa10c6a314eb014fb9b">observable::delay</a> (auto &amp;&amp;delay_duration, TScheduler &amp;&amp;scheduler) const &amp;</td></tr>
<tr class="memdesc:gaaf883140cd425aa10c6a314eb014fb9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the emissions from an Observable forward in time by a particular amount.  <br /></td></tr>
<tr class="separator:gaaf883140cd425aa10c6a314eb014fb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga134878936c20b1ef87d3c655ceffc131"><td class="memTemplParams" colspan="2">template&lt;constraint::observer_of_type&lt; Type &gt; TObs&gt; <br />
requires is_header_included &lt;do_tag, TObs&gt;</td></tr>
<tr class="memitem:ga134878936c20b1ef87d3c655ceffc131"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#ga134878936c20b1ef87d3c655ceffc131">observable::tap</a> (TObs &amp;&amp;observer) const &amp;</td></tr>
<tr class="memdesc:ga134878936c20b1ef87d3c655ceffc131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an observer to be called when observable provides any events (on_next/on_error/on_completed)  <br /></td></tr>
<tr class="separator:ga134878936c20b1ef87d3c655ceffc131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga345385e805cd439432d447065727df09"><td class="memTemplParams" colspan="2">template&lt;constraint::on_next_fn&lt; Type &gt; OnNextFn, constraint::on_error_fn OnErrorFn = utils::empty_function_t&lt;std::exception_ptr&gt;, constraint::on_completed_fn OnCompletedFn = utils::empty_function_t&lt;&gt;&gt; <br />
requires is_header_included &lt;do_tag, OnNextFn, OnErrorFn, OnCompletedFn&gt;</td></tr>
<tr class="memitem:ga345385e805cd439432d447065727df09"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#ga345385e805cd439432d447065727df09">observable::tap</a> (OnNextFn &amp;&amp;on_next, OnErrorFn &amp;&amp;on_error=OnErrorFn{}, OnCompletedFn &amp;&amp;on_completed=OnCompletedFn{}) const &amp;</td></tr>
<tr class="memdesc:ga345385e805cd439432d447065727df09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an list of actions to be called when observable provides any events (on_next/on_error/on_completed)  <br /></td></tr>
<tr class="separator:ga345385e805cd439432d447065727df09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e80d15de566a980aa0ddcb2c529977f"><td class="memTemplParams" colspan="2">template&lt;constraint::on_next_fn&lt; Type &gt; OnNextFn&gt; <br />
requires is_header_included &lt;do_tag, OnNextFn&gt;</td></tr>
<tr class="memitem:ga1e80d15de566a980aa0ddcb2c529977f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#ga1e80d15de566a980aa0ddcb2c529977f">observable::do_on_next</a> (OnNextFn &amp;&amp;on_next) const &amp;</td></tr>
<tr class="memdesc:ga1e80d15de566a980aa0ddcb2c529977f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an callback to be called when observable provides new item (on_next)  <br /></td></tr>
<tr class="separator:ga1e80d15de566a980aa0ddcb2c529977f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9089d55867fc04d1f353dc636e519634"><td class="memTemplParams" colspan="2">template&lt;constraint::on_error_fn OnErrorFn&gt; <br />
requires is_header_included &lt;do_tag, OnErrorFn&gt;</td></tr>
<tr class="memitem:ga9089d55867fc04d1f353dc636e519634"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#ga9089d55867fc04d1f353dc636e519634">observable::do_on_error</a> (OnErrorFn &amp;&amp;on_error) const &amp;</td></tr>
<tr class="memdesc:ga9089d55867fc04d1f353dc636e519634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an callback to be called when observable provides error (on_error)  <br /></td></tr>
<tr class="separator:ga9089d55867fc04d1f353dc636e519634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d6dfc49bf54893033b45b530f0fcb38"><td class="memTemplParams" colspan="2">template&lt;constraint::on_completed_fn OnCompletedFn&gt; <br />
requires is_header_included &lt;do_tag, OnCompletedFn&gt;</td></tr>
<tr class="memitem:ga2d6dfc49bf54893033b45b530f0fcb38"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#ga2d6dfc49bf54893033b45b530f0fcb38">observable::do_on_completed</a> (OnCompletedFn &amp;&amp;on_completed) const &amp;</td></tr>
<tr class="memdesc:ga2d6dfc49bf54893033b45b530f0fcb38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register an callback to be called when observable provides complete (on_completed)  <br /></td></tr>
<tr class="separator:ga2d6dfc49bf54893033b45b530f0fcb38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga374d453301a31f00fed7024be4327934"><td class="memTemplParams" colspan="2">template&lt;schedulers::constraint::scheduler TScheduler&gt; <br />
requires is_header_included&lt;observe_on_tag, TScheduler&gt;</td></tr>
<tr class="memitem:ga374d453301a31f00fed7024be4327934"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#ga374d453301a31f00fed7024be4327934">observable::observe_on</a> (TScheduler &amp;&amp;scheduler) const &amp;</td></tr>
<tr class="memdesc:ga374d453301a31f00fed7024be4327934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit emissions of observable starting from this point via provided scheduler.  <br /></td></tr>
<tr class="separator:ga374d453301a31f00fed7024be4327934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a165810b188f9cf9b77255ed725e31a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires is_header_included&lt;repeat_tag, Args...&gt;</td></tr>
<tr class="memitem:ga2a165810b188f9cf9b77255ed725e31a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#ga2a165810b188f9cf9b77255ed725e31a">observable::repeat</a> (size_t count) const &amp;</td></tr>
<tr class="memdesc:ga2a165810b188f9cf9b77255ed725e31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-subscribes on current observable during <code>on_completed</code> provided amount of times.  <br /></td></tr>
<tr class="separator:ga2a165810b188f9cf9b77255ed725e31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga152a343d0ea926ee04cf64ebb78c5d5e"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; <br />
requires is_header_included&lt;repeat_tag, Args...&gt;</td></tr>
<tr class="memitem:ga152a343d0ea926ee04cf64ebb78c5d5e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#ga152a343d0ea926ee04cf64ebb78c5d5e">observable::repeat</a> () const &amp;</td></tr>
<tr class="memdesc:ga152a343d0ea926ee04cf64ebb78c5d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-subscribes on current observable during <code>on_completed</code> infinitely.  <br /></td></tr>
<tr class="separator:ga152a343d0ea926ee04cf64ebb78c5d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2272435c76e0830c70e111b3270cd3d4"><td class="memTemplParams" colspan="2">template&lt;schedulers::constraint::scheduler TScheduler&gt; <br />
requires is_header_included&lt;subscribe_on_tag, TScheduler&gt;</td></tr>
<tr class="memitem:ga2272435c76e0830c70e111b3270cd3d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#ga2272435c76e0830c70e111b3270cd3d4">observable::subscribe_on</a> (const TScheduler &amp;scheduler) const &amp;</td></tr>
<tr class="memdesc:ga2272435c76e0830c70e111b3270cd3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">OnSubscribe function for this observable will be scheduled via provided scheduler.  <br /></td></tr>
<tr class="separator:ga2272435c76e0830c70e111b3270cd3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4266aff14b3f5313031cca946369ea25"><td class="memTemplParams" colspan="2">template&lt;constraint::observable_of_type&lt; Type &gt; FallbackObs, schedulers::constraint::scheduler TScheduler&gt; <br />
requires is_header_included&lt;timeout_tag, FallbackObs, TScheduler&gt;</td></tr>
<tr class="memitem:ga4266aff14b3f5313031cca946369ea25"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#ga4266aff14b3f5313031cca946369ea25">observable::timeout</a> (schedulers::duration period, FallbackObs &amp;&amp;fallback_obs, const TScheduler &amp;scheduler=TScheduler{}) const &amp;</td></tr>
<tr class="memdesc:ga4266aff14b3f5313031cca946369ea25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards emissions from original observable, but subscribes on fallback observable if no any events during specified period of time (since last emission)  <br /></td></tr>
<tr class="separator:ga4266aff14b3f5313031cca946369ea25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae93d14e68fd17524ebc1ac48e6bf35f"><td class="memTemplParams" colspan="2">template&lt;schedulers::constraint::scheduler TScheduler&gt; <br />
requires is_header_included&lt;timeout_tag, TScheduler&gt;</td></tr>
<tr class="memitem:gaae93d14e68fd17524ebc1ac48e6bf35f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__operators.html#gaae93d14e68fd17524ebc1ac48e6bf35f">observable::timeout</a> (schedulers::duration period, const TScheduler &amp;scheduler=TScheduler{}) const &amp;</td></tr>
<tr class="memdesc:gaae93d14e68fd17524ebc1ac48e6bf35f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards emissions from original observable, but emit error if no any events during specified period of time (since last emission)  <br /></td></tr>
<tr class="separator:gaae93d14e68fd17524ebc1ac48e6bf35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Utility operators are operators that provide some extra functionality without changing of original values, but changing of behaviour. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators.html#utility">https://reactivex.io/documentation/operators.html#utility</a> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaaf883140cd425aa10c6a314eb014fb9b" name="gaaf883140cd425aa10c6a314eb014fb9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf883140cd425aa10c6a314eb014fb9b">&#9670;&#160;</a></span>delay()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;schedulers::constraint::scheduler TScheduler&gt; <br />
requires is_header_included&lt;delay_tag, TScheduler&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::delay </td>
          <td>(</td>
          <td class="paramtype">auto &amp;&amp;&#160;</td>
          <td class="paramname"><em>delay_duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TScheduler &amp;&amp;&#160;</td>
          <td class="paramname"><em>scheduler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift the emissions from an Observable forward in time by a particular amount. </p>
<p>The delay operator modifies its source Observable by pausing for a particular increment of time (that you specify) before emitting each of the source Observable’s items. This has the effect of shifting the entire sequence of items emitted by the Observable forward in time by that specified increment.</p>
<div class="image">
<object type="image/svg+xml" data="delay.svg" style="pointer-events: none;"></object>
</div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delay_duration</td><td>is the delay duration for emitting items. Delay duration should be able to cast to rpp::schedulers::duration. </td></tr>
    <tr><td class="paramname">scheduler</td><td>provides the threading model for delay. e.g. With a new thread scheduler, the observer sees the values in a new thread after a delay duration to the subscription. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the delay operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="delay_8hpp_source.html">rpp/operators/delay.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> start = rpp::schedulers::clock_type::now();</div>
<div class="line"> </div>
<div class="line">    rpp::source::just(1, 2, 3)</div>
<div class="line">            .do_on_next([&amp;](<span class="keyword">auto</span>&amp;&amp; v)</div>
<div class="line">                        {</div>
<div class="line">                            <span class="keyword">auto</span> emitting_time = rpp::schedulers::clock_type::now();</div>
<div class="line">                            std::cout &lt;&lt; <span class="stringliteral">&quot;emit &quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; in thread{&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="stringliteral">&quot;} duration since start &quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(emitting_time - start).count() &lt;&lt; <span class="stringliteral">&quot;s&quot;</span>&lt;&lt; std::endl;</div>
<div class="line">                        })</div>
<div class="line">            .<a class="code hl_function" href="group__utility__operators.html#gaaf883140cd425aa10c6a314eb014fb9b">delay</a>(std::chrono::seconds{3}, <a class="code hl_class" href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a>{})</div>
<div class="line">            .as_blocking()</div>
<div class="line">            .subscribe([&amp;](<span class="keywordtype">int</span> v)</div>
<div class="line">                       {</div>
<div class="line">                           <span class="keyword">auto</span> observing_time = rpp::schedulers::clock_type::now();</div>
<div class="line">                           std::cout &lt;&lt; <span class="stringliteral">&quot;observe &quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; in thread{&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="stringliteral">&quot;} duration since start &quot;</span> &lt;&lt; std::chrono::duration_cast&lt;std::chrono::seconds&gt;(observing_time - start).count() &lt;&lt;<span class="stringliteral">&quot;s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                       });</div>
<div class="line">    <span class="comment">// Template for output:</span></div>
<div class="line">    <span class="comment">//    emit 1 in thread{11772} duration since start 0s</span></div>
<div class="line">    <span class="comment">//    emit 2 in thread{11772} duration since start 0s</span></div>
<div class="line">    <span class="comment">//    emit 3 in thread{11772} duration since start 0s</span></div>
<div class="line">    <span class="comment">//    observe 1 in thread{15516} duration since start 3s</span></div>
<div class="line">    <span class="comment">//    observe 2 in thread{15516} duration since start 3s</span></div>
<div class="line">    <span class="comment">//    observe 3 in thread{15516} duration since start 3s</span></div>
<div class="ttc" id="aclassrpp_1_1schedulers_1_1new__thread_html"><div class="ttname"><a href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a></div><div class="ttdoc">scheduler which schedules execution of schedulables via queueing tasks to another thread with priorit...</div><div class="ttdef"><b>Definition:</b> new_thread_scheduler.hpp:32</div></div>
<div class="ttc" id="agroup__utility__operators_html_gaaf883140cd425aa10c6a314eb014fb9b"><div class="ttname"><a href="group__utility__operators.html#gaaf883140cd425aa10c6a314eb014fb9b">observable::delay</a></div><div class="ttdeci">auto delay(auto &amp;&amp;delay_duration, TScheduler &amp;&amp;scheduler) const &amp;</div><div class="ttdoc">Shift the emissions from an Observable forward in time by a particular amount.</div><div class="ttdef"><b>Definition:</b> delay.hpp:48</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/delay.html">https://reactivex.io/documentation/operators/delay.html</a> </dd></dl>

</div>
</div>
<a id="ga2d6dfc49bf54893033b45b530f0fcb38" name="ga2d6dfc49bf54893033b45b530f0fcb38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d6dfc49bf54893033b45b530f0fcb38">&#9670;&#160;</a></span>do_on_completed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;constraint::on_completed_fn OnCompletedFn&gt; <br />
requires is_header_included &lt;do_tag, OnCompletedFn&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::do_on_completed </td>
          <td>(</td>
          <td class="paramtype">OnCompletedFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_completed</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register an callback to be called when observable provides complete (on_completed) </p>
<dl class="section note"><dt>Note</dt><dd>on_completed from <code>tap</code> would be invoked BEFORE on_completed from subscriber</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_completed</td><td>- action in case of completion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the do_on_completed operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="do_8hpp_source.html">rpp/operators/do.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">    rpp::source::empty&lt;int&gt;()</div>
<div class="line">            .do_on_completed([]() { std::cout &lt;&lt; <span class="stringliteral">&quot;(TAP) Completed&quot;</span> &lt;&lt; std::endl; })</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span>) {}, []() { std::cout &lt;&lt; <span class="stringliteral">&quot;Completed&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">    <span class="comment">// Output:</span></div>
<div class="line">    <span class="comment">// (TAP) Completed</span></div>
<div class="line">    <span class="comment">// Completed</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/do.html">https://reactivex.io/documentation/operators/do.html</a> </dd></dl>

</div>
</div>
<a id="ga9089d55867fc04d1f353dc636e519634" name="ga9089d55867fc04d1f353dc636e519634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9089d55867fc04d1f353dc636e519634">&#9670;&#160;</a></span>do_on_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;constraint::on_error_fn OnErrorFn&gt; <br />
requires is_header_included &lt;do_tag, OnErrorFn&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::do_on_error </td>
          <td>(</td>
          <td class="paramtype">OnErrorFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_error</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register an callback to be called when observable provides error (on_error) </p>
<dl class="section note"><dt>Note</dt><dd>on_error from <code>tap</code> would be invoked BEFORE on_error from subscriber</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_error</td><td>- action over std::exception_ptr in case of any error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the do_on_error operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="do_8hpp_source.html">rpp/operators/do.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">    rpp::source::error&lt;int&gt;(std::make_exception_ptr(std::runtime_error{<span class="stringliteral">&quot;&quot;</span>}))</div>
<div class="line">            .do_on_error([](std::exception_ptr) { std::cout &lt;&lt; <span class="stringliteral">&quot;(TAP) NEW error&quot;</span> &lt;&lt; std::endl; })</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span>                 ) {}, [](std::exception_ptr) { std::cout &lt;&lt; <span class="stringliteral">&quot;NEW error&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">    <span class="comment">// Output:</span></div>
<div class="line">    <span class="comment">// (TAP) NEW error</span></div>
<div class="line">    <span class="comment">// NEW error</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/do.html">https://reactivex.io/documentation/operators/do.html</a> </dd></dl>

</div>
</div>
<a id="ga1e80d15de566a980aa0ddcb2c529977f" name="ga1e80d15de566a980aa0ddcb2c529977f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e80d15de566a980aa0ddcb2c529977f">&#9670;&#160;</a></span>do_on_next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;constraint::on_next_fn&lt; Type &gt; OnNextFn&gt; <br />
requires is_header_included &lt;do_tag, OnNextFn&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::do_on_next </td>
          <td>(</td>
          <td class="paramtype">OnNextFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_next</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register an callback to be called when observable provides new item (on_next) </p>
<dl class="section note"><dt>Note</dt><dd>on_next from <code>tap</code> would be invoked BEFORE on_next from subscriber</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_next</td><td>- action over new emitted item</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the do_on_next operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="do_8hpp_source.html">rpp/operators/do.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">    rpp::source::just(1, 2)</div>
<div class="line">            .do_on_next([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; <span class="stringliteral">&quot;(TAP) NEW item &quot;</span> &lt;&lt; v &lt;&lt; std::endl; })</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span>  v) { std::cout &lt;&lt; <span class="stringliteral">&quot;NEW item &quot;</span> &lt;&lt; v &lt;&lt; std::endl; },</div>
<div class="line">                       []() { std::cout &lt;&lt; <span class="stringliteral">&quot;Completed&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">    <span class="comment">// Output:</span></div>
<div class="line">    <span class="comment">// (TAP) NEW item 1</span></div>
<div class="line">    <span class="comment">// NEW item 1</span></div>
<div class="line">    <span class="comment">// (TAP) NEW item 2</span></div>
<div class="line">    <span class="comment">// NEW item 2</span></div>
<div class="line">    <span class="comment">// Completed</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/do.html">https://reactivex.io/documentation/operators/do.html</a> </dd></dl>

</div>
</div>
<a id="ga374d453301a31f00fed7024be4327934" name="ga374d453301a31f00fed7024be4327934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga374d453301a31f00fed7024be4327934">&#9670;&#160;</a></span>observe_on()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;schedulers::constraint::scheduler TScheduler&gt; <br />
requires is_header_included&lt;observe_on_tag, TScheduler&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::observe_on </td>
          <td>(</td>
          <td class="paramtype">TScheduler &amp;&amp;&#160;</td>
          <td class="paramname"><em>scheduler</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emit emissions of observable starting from this point via provided scheduler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scheduler</td><td>is scheduler used for scheduling of OnNext </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the observe_on operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="observe__on_8hpp_source.html">rpp/operators/observe_on.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">    std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</div>
<div class="line">    rpp::source::just(10, 15, 20)</div>
<div class="line">            .observe_on(<a class="code hl_class" href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a>{})</div>
<div class="line">            .as_blocking()</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="stringliteral">&quot;] : &quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; });</div>
<div class="line">    <span class="comment">// Template for output:</span></div>
<div class="line">    <span class="comment">// TH1</span></div>
<div class="line">    <span class="comment">// [TH2]: 10</span></div>
<div class="line">    <span class="comment">// [TH2]: 15</span></div>
<div class="line">    <span class="comment">// [TH2]: 20</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/observeon.html">https://reactivex.io/documentation/operators/observeon.html</a> </dd></dl>

</div>
</div>
<a id="ga152a343d0ea926ee04cf64ebb78c5d5e" name="ga152a343d0ea926ee04cf64ebb78c5d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga152a343d0ea926ee04cf64ebb78c5d5e">&#9670;&#160;</a></span>repeat() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires is_header_included&lt;repeat_tag, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::repeat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-subscribes on current observable during <code>on_completed</code> infinitely. </p>
<div class="image">
<object type="image/svg+xml" data="repeat_infinitely.svg" style="pointer-events: none;"></object>
</div>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the repeat operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="repeat_8hpp_source.html">rpp/operators/repeat.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Examples:</dt><dd><div class="fragment"><div class="line">    rpp::source::just(1, 2, 3)</div>
<div class="line">            .repeat()</div>
<div class="line">            .take(10)</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; },</div>
<div class="line">                       []()</div>
<div class="line">                       {</div>
<div class="line">                           std::cout &lt;&lt; <span class="stringliteral">&quot;completed&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                       });</div>
<div class="line">    <span class="comment">// Output: 1 2 3 1 2 3 1 2 3 1 completed</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/repeat.html">https://reactivex.io/documentation/operators/repeat.html</a> </dd></dl>

</div>
</div>
<a id="ga2a165810b188f9cf9b77255ed725e31a" name="ga2a165810b188f9cf9b77255ed725e31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a165810b188f9cf9b77255ed725e31a">&#9670;&#160;</a></span>repeat() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; <br />
requires is_header_included&lt;repeat_tag, Args...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::repeat </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-subscribes on current observable during <code>on_completed</code> provided amount of times. </p>
<div class="image">
<object type="image/svg+xml" data="repeat.svg" style="pointer-events: none;"></object>
</div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>total amount of times subscription happens. For example:<ul>
<li><code>count(0)</code> - means no any subscription at all</li>
<li><code>count(1)</code> - behave like ordinal observable</li>
<li><code>count(10)</code> - 1 normal subscription and 9 re-subscriptions during on_completed </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the repeat operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="repeat_8hpp_source.html">rpp/operators/repeat.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Examples:</dt><dd><div class="fragment"><div class="line">    rpp::source::just(1, 2, 3)</div>
<div class="line">            .repeat(2)</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; },</div>
<div class="line">                       []()</div>
<div class="line">                       {</div>
<div class="line">                           std::cout &lt;&lt; <span class="stringliteral">&quot;completed&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                       });</div>
<div class="line">    <span class="comment">// Output: 1 2 3 1 2 3 completed</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/repeat.html">https://reactivex.io/documentation/operators/repeat.html</a> </dd></dl>

</div>
</div>
<a id="ga2272435c76e0830c70e111b3270cd3d4" name="ga2272435c76e0830c70e111b3270cd3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2272435c76e0830c70e111b3270cd3d4">&#9670;&#160;</a></span>subscribe_on()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;schedulers::constraint::scheduler TScheduler&gt; <br />
requires is_header_included&lt;subscribe_on_tag, TScheduler&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::subscribe_on </td>
          <td>(</td>
          <td class="paramtype">const TScheduler &amp;&#160;</td>
          <td class="paramname"><em>scheduler</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>OnSubscribe function for this observable will be scheduled via provided scheduler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scheduler</td><td>is scheduler used for scheduling of OnSubscribe </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the subscribe_on operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="subscribe__on_8hpp_source.html">rpp/operators/subscribe_on.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">    std::cout &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</div>
<div class="line">    rpp::source::create&lt;int&gt;([](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; sub)</div>
<div class="line">            {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;on_subscribe thread &quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</div>
<div class="line">                sub.on_next(1);</div>
<div class="line">                sub.on_completed();</div>
<div class="line">            })</div>
<div class="line">            .<a class="code hl_function" href="group__utility__operators.html#ga2272435c76e0830c70e111b3270cd3d4">subscribe_on</a>(<a class="code hl_class" href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a>{})</div>
<div class="line">            .as_blocking()</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; std::this_thread::get_id() &lt;&lt; <span class="stringliteral">&quot;] : &quot;</span> &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>; });</div>
<div class="line">    <span class="comment">// Template for output:</span></div>
<div class="line">    <span class="comment">// TH1</span></div>
<div class="line">    <span class="comment">// on_subscribe thread TH2</span></div>
<div class="line">    <span class="comment">// [TH2]: 1</span></div>
<div class="ttc" id="agroup__utility__operators_html_ga2272435c76e0830c70e111b3270cd3d4"><div class="ttname"><a href="group__utility__operators.html#ga2272435c76e0830c70e111b3270cd3d4">observable::subscribe_on</a></div><div class="ttdeci">auto subscribe_on(const TScheduler &amp;scheduler) const &amp;</div><div class="ttdoc">OnSubscribe function for this observable will be scheduled via provided scheduler.</div><div class="ttdef"><b>Definition:</b> subscribe_on.hpp:44</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/subscribeon.html">https://reactivex.io/documentation/operators/subscribeon.html</a> </dd></dl>

</div>
</div>
<a id="ga345385e805cd439432d447065727df09" name="ga345385e805cd439432d447065727df09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga345385e805cd439432d447065727df09">&#9670;&#160;</a></span>tap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;constraint::on_next_fn&lt; Type &gt; OnNextFn, constraint::on_error_fn OnErrorFn = utils::empty_function_t&lt;std::exception_ptr&gt;, constraint::on_completed_fn OnCompletedFn = utils::empty_function_t&lt;&gt;&gt; <br />
requires is_header_included &lt;do_tag, OnNextFn, OnErrorFn, OnCompletedFn&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::tap </td>
          <td>(</td>
          <td class="paramtype">OnNextFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OnErrorFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_error</em> = <code>OnErrorFn{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OnCompletedFn &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_completed</em> = <code>OnCompletedFn{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register an list of actions to be called when observable provides any events (on_next/on_error/on_completed) </p>
<dl class="section note"><dt>Note</dt><dd>Callbacks from <code>tap</code> would be invoked BEFORE subscribed subscriber</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">on_next</td><td>- action over new emitted item </td></tr>
    <tr><td class="paramname">on_error</td><td>- action over std::exception_ptr in case of any error </td></tr>
    <tr><td class="paramname">on_completed</td><td>- action in case of completion</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the tap operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="do_8hpp_source.html">rpp/operators/do.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">    rpp::source::just(1, 2)</div>
<div class="line">            .tap([](<span class="keywordtype">int</span>               v) { std::cout &lt;&lt; <span class="stringliteral">&quot;(TAP) NEW item &quot;</span> &lt;&lt; v &lt;&lt; std::endl; },</div>
<div class="line">                 [](std::exception_ptr) {},</div>
<div class="line">                 []() { std::cout &lt;&lt; <span class="stringliteral">&quot;(TAP) Completed&quot;</span> &lt;&lt; std::endl; })</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; <span class="stringliteral">&quot;NEW item &quot;</span> &lt;&lt; v &lt;&lt; std::endl; },</div>
<div class="line">                       []() { std::cout &lt;&lt; <span class="stringliteral">&quot;Completed&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">    <span class="comment">// Output:</span></div>
<div class="line">    <span class="comment">// (TAP) NEW item 1</span></div>
<div class="line">    <span class="comment">// NEW item 1</span></div>
<div class="line">    <span class="comment">// (TAP) NEW item 2</span></div>
<div class="line">    <span class="comment">// NEW item 2</span></div>
<div class="line">    <span class="comment">// (TAP) Completed</span></div>
<div class="line">    <span class="comment">// Completed</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/do.html">https://reactivex.io/documentation/operators/do.html</a> </dd></dl>

</div>
</div>
<a id="ga134878936c20b1ef87d3c655ceffc131" name="ga134878936c20b1ef87d3c655ceffc131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga134878936c20b1ef87d3c655ceffc131">&#9670;&#160;</a></span>tap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;constraint::observer_of_type&lt; Type &gt; TObs&gt; <br />
requires is_header_included &lt;do_tag, TObs&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::tap </td>
          <td>(</td>
          <td class="paramtype">TObs &amp;&amp;&#160;</td>
          <td class="paramname"><em>observer</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register an observer to be called when observable provides any events (on_next/on_error/on_completed) </p>
<dl class="section note"><dt>Note</dt><dd>Callbacks from <code>tap</code> would be invoked BEFORE subscribed subscriber</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observer</td><td>- observer which would accept callbacks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the tap operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="do_8hpp_source.html">rpp/operators/do.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">    rpp::source::just(1, 2)</div>
<div class="line">            .tap(rpp::make_specific_observer&lt;int&gt;([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; <span class="stringliteral">&quot;(TAP) NEW item &quot;</span> &lt;&lt; v &lt;&lt; std::endl; },</div>
<div class="line">                                                  []() { std::cout &lt;&lt; <span class="stringliteral">&quot;(TAP) Completed&quot;</span> &lt;&lt; std::endl; }))</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; <span class="stringliteral">&quot;NEW item &quot;</span> &lt;&lt; v &lt;&lt; std::endl; },</div>
<div class="line">                       []() { std::cout &lt;&lt; <span class="stringliteral">&quot;Completed&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">    <span class="comment">// Output:</span></div>
<div class="line">    <span class="comment">// (TAP) NEW item 1</span></div>
<div class="line">    <span class="comment">// NEW item 1</span></div>
<div class="line">    <span class="comment">// (TAP) NEW item 2</span></div>
<div class="line">    <span class="comment">// NEW item 2</span></div>
<div class="line">    <span class="comment">// (TAP) Completed</span></div>
<div class="line">    <span class="comment">// Completed</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/do.html">https://reactivex.io/documentation/operators/do.html</a> </dd></dl>

</div>
</div>
<a id="gaae93d14e68fd17524ebc1ac48e6bf35f" name="gaae93d14e68fd17524ebc1ac48e6bf35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae93d14e68fd17524ebc1ac48e6bf35f">&#9670;&#160;</a></span>timeout() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;schedulers::constraint::scheduler TScheduler&gt; <br />
requires is_header_included&lt;timeout_tag, TScheduler&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::timeout </td>
          <td>(</td>
          <td class="paramtype">schedulers::duration&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TScheduler &amp;&#160;</td>
          <td class="paramname"><em>scheduler</em> = <code>TScheduler{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwards emissions from original observable, but emit error if no any events during specified period of time (since last emission) </p>
<div class="image">
<object type="image/svg+xml" data="timeout.svg" style="pointer-events: none;"></object>
</div>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>is maximum duration between emitted items before a timeout occurs </td></tr>
    <tr><td class="paramname">scheduler</td><td>is scheduler used to run timer for timeout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the timeout operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="timeout_8hpp_source.html">rpp/operators/timeout.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">        <a class="code hl_class" href="classrpp_1_1subjects_1_1publish__subject.html">rpp::subjects::publish_subject&lt;int&gt;</a> subj{};</div>
<div class="line">        subj.get_observable()</div>
<div class="line">            .timeout(std::chrono::milliseconds{450}, <a class="code hl_class" href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a>{})</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span>                v) { std::cout &lt;&lt; <span class="stringliteral">&quot;new value &quot;</span> &lt;&lt; v &lt;&lt; std::endl; },</div>
<div class="line">                       [](std::exception_ptr err)</div>
<div class="line">                       {</div>
<div class="line">                           <span class="keywordflow">try</span></div>
<div class="line">                           {</div>
<div class="line">                               std::rethrow_exception(err);</div>
<div class="line">                           }</div>
<div class="line">                           <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; exc)</div>
<div class="line">                           {</div>
<div class="line">                               std::cout &lt;&lt; <span class="stringliteral">&quot;ERR: &quot;</span> &lt;&lt; exc.what() &lt;&lt; std::endl;</div>
<div class="line">                           }</div>
<div class="line">                       },</div>
<div class="line">                       []() { std::cout &lt;&lt; <span class="stringliteral">&quot;completed&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; ++i)</div>
<div class="line">        {</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds{i * 100});</div>
<div class="line">            subj.get_subscriber().on_next(i);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Output:</span></div>
<div class="line">        <span class="comment">// new value 0</span></div>
<div class="line">        <span class="comment">// new value 1</span></div>
<div class="line">        <span class="comment">// new value 2</span></div>
<div class="line">        <span class="comment">// new value 3</span></div>
<div class="line">        <span class="comment">// new value 4</span></div>
<div class="line">        <span class="comment">// ERR : Timeout reached</span></div>
<div class="ttc" id="aclassrpp_1_1subjects_1_1publish__subject_html"><div class="ttname"><a href="classrpp_1_1subjects_1_1publish__subject.html">rpp::subjects::publish_subject</a></div><div class="ttdoc">Subject which just multicasts values to observers subscribed on it. It contains two parts: subscriber...</div><div class="ttdef"><b>Definition:</b> publish_subject.hpp:78</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/timeout.html">https://reactivex.io/documentation/operators/timeout.html</a> </dd></dl>

</div>
</div>
<a id="ga4266aff14b3f5313031cca946369ea25" name="ga4266aff14b3f5313031cca946369ea25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4266aff14b3f5313031cca946369ea25">&#9670;&#160;</a></span>timeout() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;constraint::observable_of_type&lt; Type &gt; FallbackObs, schedulers::constraint::scheduler TScheduler&gt; <br />
requires is_header_included&lt;timeout_tag, FallbackObs, TScheduler&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::timeout </td>
          <td>(</td>
          <td class="paramtype">schedulers::duration&#160;</td>
          <td class="paramname"><em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FallbackObs &amp;&amp;&#160;</td>
          <td class="paramname"><em>fallback_obs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TScheduler &amp;&#160;</td>
          <td class="paramname"><em>scheduler</em> = <code>TScheduler{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwards emissions from original observable, but subscribes on fallback observable if no any events during specified period of time (since last emission) </p>
<div class="image">
<object type="image/svg+xml" data="timeout_fallback_obs.svg" style="pointer-events: none;"></object>
</div>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">period</td><td>is maximum duration between emitted items before a timeout occurs </td></tr>
    <tr><td class="paramname">fallback_obs</td><td>is observable to subscribe on when timeout reached </td></tr>
    <tr><td class="paramname">scheduler</td><td>is scheduler used to run timer for timeout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the timeout operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="timeout_8hpp_source.html">rpp/operators/timeout.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">        <a class="code hl_class" href="classrpp_1_1subjects_1_1publish__subject.html">rpp::subjects::publish_subject&lt;int&gt;</a> subj{};</div>
<div class="line">        subj.get_observable()</div>
<div class="line">            .timeout(std::chrono::milliseconds{450}, rpp::source::just(100), <a class="code hl_class" href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a>{})</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span>                v) { std::cout &lt;&lt; <span class="stringliteral">&quot;new value &quot;</span> &lt;&lt; v &lt;&lt; std::endl; },</div>
<div class="line">                       []() { std::cout &lt;&lt; <span class="stringliteral">&quot;completed&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; ++i)</div>
<div class="line">        {</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds{i * 100});</div>
<div class="line">            subj.get_subscriber().on_next(i);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Output:</span></div>
<div class="line">        <span class="comment">//new value 0</span></div>
<div class="line">        <span class="comment">//new value 1</span></div>
<div class="line">        <span class="comment">//new value 2</span></div>
<div class="line">        <span class="comment">//new value 3</span></div>
<div class="line">        <span class="comment">//new value 4</span></div>
<div class="line">        <span class="comment">//new value 100</span></div>
<div class="line">        <span class="comment">//completed</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/timeout.html">https://reactivex.io/documentation/operators/timeout.html</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
