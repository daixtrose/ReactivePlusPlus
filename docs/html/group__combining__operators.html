<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ReactivePlusPlus: Combining Operators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ReactivePlusPlus
   </div>
   <div id="projectbrief">One more implementation of ReactiveX approach in C++ with care about performance and templates in mind</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__combining__operators.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Combining Operators<div class="ingroups"><a class="el" href="group__rpp.html">RPP</a> &raquo; <a class="el" href="group__operators.html">Operators</a></div></div></div>
</div><!--header-->
<div class="contents">

<p>Combining operators are operators that combines emissions of multiple observables into same observable by some rule.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga235795a45f5c6db3f6ec75204ab2d8a2"><td class="memTemplParams" colspan="2">template&lt;constraint::observable ... TOtherObservable, std::invocable&lt; Type, utils::extract_observable_type_t&lt; TOtherObservable &gt;... &gt; TCombiner&gt; <br />
requires is_header_included&lt;combine_latest_tag, TOtherObservable...&gt;</td></tr>
<tr class="memitem:ga235795a45f5c6db3f6ec75204ab2d8a2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__combining__operators.html#ga235795a45f5c6db3f6ec75204ab2d8a2">observable::combine_latest</a> (TCombiner &amp;&amp;combiner, TOtherObservable &amp;&amp;...observables) const &amp;</td></tr>
<tr class="memdesc:ga235795a45f5c6db3f6ec75204ab2d8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines latest emissions from original observable and other observables when any of them emits.  <br /></td></tr>
<tr class="separator:ga235795a45f5c6db3f6ec75204ab2d8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd8deec9fdd88032d272e097c2b70657"><td class="memTemplParams" colspan="2">template&lt;constraint::observable ... TOtherObservable&gt; <br />
requires is_header_included&lt;combine_latest_tag, TOtherObservable...&gt;</td></tr>
<tr class="memitem:gacd8deec9fdd88032d272e097c2b70657"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__combining__operators.html#gacd8deec9fdd88032d272e097c2b70657">observable::combine_latest</a> (TOtherObservable &amp;&amp;...observables) const &amp;</td></tr>
<tr class="memdesc:gacd8deec9fdd88032d272e097c2b70657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines latest emissions from current observable and other observables when any of them emits. The combining result is std::tuple&lt;...&gt;.  <br /></td></tr>
<tr class="separator:gacd8deec9fdd88032d272e097c2b70657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84ed0dcdeda6a4cb3a9871ab2817e114"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; <br />
requires (is_header_included&lt;merge_tag, Args...&gt; &amp;&amp; <a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a>&lt;Type&gt;)</td></tr>
<tr class="memitem:ga84ed0dcdeda6a4cb3a9871ab2817e114"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__combining__operators.html#ga84ed0dcdeda6a4cb3a9871ab2817e114">observable::merge</a> () const &amp;</td></tr>
<tr class="memdesc:ga84ed0dcdeda6a4cb3a9871ab2817e114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts observable of observables of items into observable of items via merging emissions.  <br /></td></tr>
<tr class="separator:ga84ed0dcdeda6a4cb3a9871ab2817e114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa55b14eec1c6c40b8655e20c6edf5b2"><td class="memTemplParams" colspan="2">template&lt;constraint::observable_of_type&lt; Type &gt; ... TObservables&gt; <br />
requires (is_header_included&lt;merge_tag, TObservables...&gt;&amp;&amp; sizeof...(TObservables) &gt;= 1)</td></tr>
<tr class="memitem:gafa55b14eec1c6c40b8655e20c6edf5b2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__combining__operators.html#gafa55b14eec1c6c40b8655e20c6edf5b2">observable::merge_with</a> (TObservables &amp;&amp;... observables) const &amp;</td></tr>
<tr class="memdesc:gafa55b14eec1c6c40b8655e20c6edf5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines submissions from current observable with other observables into one.  <br /></td></tr>
<tr class="separator:gafa55b14eec1c6c40b8655e20c6edf5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaced47c11cd4cea804a6d0f7c33be2fa0"><td class="memTemplParams" colspan="2">template&lt;rpp::memory_model memory_model = memory_model::use_stack, constraint::decayed_same_as&lt; Type &gt; ... TTypes&gt; <br />
requires is_header_included&lt;start_with_tag, TTypes...&gt;</td></tr>
<tr class="memitem:gaced47c11cd4cea804a6d0f7c33be2fa0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__combining__operators.html#gaced47c11cd4cea804a6d0f7c33be2fa0">observable::start_with</a> (TTypes &amp;&amp;...vals_to_start_with) const &amp;</td></tr>
<tr class="memdesc:gaced47c11cd4cea804a6d0f7c33be2fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines submissions from current observable with values into one but without overlapping and starting from values provided as arguments.  <br /></td></tr>
<tr class="separator:gaced47c11cd4cea804a6d0f7c33be2fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf86bfdf7b2026804303f5b468fa22480"><td class="memTemplParams" colspan="2">template&lt;constraint::observable_of_type&lt; Type &gt; ... TObservables&gt; <br />
requires is_header_included&lt;start_with_tag, TObservables...&gt;</td></tr>
<tr class="memitem:gaf86bfdf7b2026804303f5b468fa22480"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__combining__operators.html#gaf86bfdf7b2026804303f5b468fa22480">observable::start_with</a> (TObservables &amp;&amp;...observables_to_start_with) const &amp;</td></tr>
<tr class="memdesc:gaf86bfdf7b2026804303f5b468fa22480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines submissions from current observable with other observables into one but without overlapping and starting from observables provided as arguments.  <br /></td></tr>
<tr class="separator:gaf86bfdf7b2026804303f5b468fa22480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e3a232da875328d9d53adf7a30c25cf"><td class="memTemplParams" colspan="2">template&lt;typename ... Args&gt; <br />
requires (is_header_included&lt;switch_on_next_tag, Args...&gt;&amp;&amp; <a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a>&lt;Type&gt;)</td></tr>
<tr class="memitem:ga2e3a232da875328d9d53adf7a30c25cf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__combining__operators.html#ga2e3a232da875328d9d53adf7a30c25cf">observable::switch_on_next</a> () const &amp;</td></tr>
<tr class="memdesc:ga2e3a232da875328d9d53adf7a30c25cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts observable of observables into observable of values which emits values from most recent underlying observable till new observable obtained.  <br /></td></tr>
<tr class="separator:ga2e3a232da875328d9d53adf7a30c25cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga805656c8847d81ace55ebc71d0598e44"><td class="memTemplParams" colspan="2">template&lt;constraint::observable ... TObservables, std::invocable&lt; Type, utils::extract_observable_type_t&lt; TObservables &gt;... &gt; TSelector&gt; <br />
requires is_header_included&lt;with_latest_from_tag, TObservables...&gt;</td></tr>
<tr class="memitem:ga805656c8847d81ace55ebc71d0598e44"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__combining__operators.html#ga805656c8847d81ace55ebc71d0598e44">observable::with_latest_from</a> (TSelector &amp;&amp;selector, TObservables &amp;&amp;...observables) const &amp;</td></tr>
<tr class="memdesc:ga805656c8847d81ace55ebc71d0598e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines latest emissions from observables with emission from current observable when it sends new value via applying selector.  <br /></td></tr>
<tr class="separator:ga805656c8847d81ace55ebc71d0598e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ea21b87312c2789a9fac07aca6037ed"><td class="memTemplParams" colspan="2">template&lt;constraint::observable ... TObservables&gt; <br />
requires is_header_included&lt;with_latest_from_tag, TObservables...&gt;</td></tr>
<tr class="memitem:ga4ea21b87312c2789a9fac07aca6037ed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__combining__operators.html#ga4ea21b87312c2789a9fac07aca6037ed">observable::with_latest_from</a> (TObservables &amp;&amp;...observables) const &amp;</td></tr>
<tr class="memdesc:ga4ea21b87312c2789a9fac07aca6037ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines latest emissions from observables with emission from current observable when it sends new value via making tuple.  <br /></td></tr>
<tr class="separator:ga4ea21b87312c2789a9fac07aca6037ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Combining operators are operators that combines emissions of multiple observables into same observable by some rule. </p>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators.html#combining">https://reactivex.io/documentation/operators.html#combining</a> </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga235795a45f5c6db3f6ec75204ab2d8a2" name="ga235795a45f5c6db3f6ec75204ab2d8a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga235795a45f5c6db3f6ec75204ab2d8a2">&#9670;&#160;</a></span>combine_latest() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;constraint::observable ... TOtherObservable, std::invocable&lt; Type, utils::extract_observable_type_t&lt; TOtherObservable &gt;... &gt; TCombiner&gt; <br />
requires is_header_included&lt;combine_latest_tag, TOtherObservable...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::combine_latest </td>
          <td>(</td>
          <td class="paramtype">TCombiner &amp;&amp;&#160;</td>
          <td class="paramname"><em>combiner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOtherObservable &amp;&amp;...&#160;</td>
          <td class="paramname"><em>observables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines latest emissions from original observable and other observables when any of them emits. </p>
<dl class="section warning"><dt>Warning</dt><dd>According to observable contract (<a href="https://reactivex.io/documentation/contract.html">https://reactivex.io/documentation/contract.html</a>) emissions from any observable should be serialized, so, resulting observable uses <code>std::mutex</code> to satisfy this requirement</dd></dl>
<div class="image">
<object type="image/svg+xml" data="combine_latest_custom_combiner.svg" style="pointer-events: none;"></object>
</div>
<p>Actually this operator subscribes on all of theses observables and emits new combined value when any of them emits new emission (and each observable emit values at least one to be able to provide combined value)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">combiner</td><td>combines emissions from all the observables using custom composition. </td></tr>
    <tr><td class="paramname">observables</td><td>are observables whose emissions would be combined with the current observable's emissions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the combine_latest operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="combine__latest_8hpp_source.html">rpp/operators/combine_latest.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line">    rpp::source::just(1, 2, 3)                                  <span class="comment">// source 1</span></div>
<div class="line">        .combine_latest(</div>
<div class="line">            [](<span class="keywordtype">int</span> left, <span class="keywordtype">int</span> right) { <span class="keywordflow">return</span> left + right; },   <span class="comment">// custom combiner</span></div>
<div class="line">            rpp::source::just(4, 5, 6))                         <span class="comment">// source 2</span></div>
<div class="line">        .subscribe(</div>
<div class="line">            [](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; <span class="stringliteral">&quot;-&quot;</span> &lt;&lt; v; },</div>
<div class="line">            [](<span class="keyword">const</span> std::exception_ptr&amp;) {},</div>
<div class="line">            []() { std::cout &lt;&lt; <span class="stringliteral">&quot;-|&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">    <span class="comment">// source 1:          -1---2---3-|</span></div>
<div class="line">    <span class="comment">// source 2: -4---5---6-| (note that source 2 is subscribed earlier than source 1)</span></div>
<div class="line">    <span class="comment">// Output  : -7-8-9-|</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Implementation details:</dt><dd><ul>
<li><b>On subscribe</b><ul>
<li>Allocates one <code>shared_ptr</code> to store last emissions.</li>
<li>Wraps subscriber with serialization logic to be sure callbacks called serialized</li>
</ul>
</li>
<li><b>OnNext</b><ul>
<li>Keeps last emission from each observable</li>
<li>Applies combiner function and emits result if there is last emissions for each observable</li>
</ul>
</li>
<li><b>OnError</b><ul>
<li>Just forwards original on_error</li>
</ul>
</li>
<li><b>OnCompleted</b><ul>
<li>Just forwards original on_completed</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/combinelatest.html">https://reactivex.io/documentation/operators/combinelatest.html</a> </dd></dl>

</div>
</div>
<a id="gacd8deec9fdd88032d272e097c2b70657" name="gacd8deec9fdd88032d272e097c2b70657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd8deec9fdd88032d272e097c2b70657">&#9670;&#160;</a></span>combine_latest() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;constraint::observable ... TOtherObservable&gt; <br />
requires is_header_included&lt;combine_latest_tag, TOtherObservable...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::combine_latest </td>
          <td>(</td>
          <td class="paramtype">TOtherObservable &amp;&amp;...&#160;</td>
          <td class="paramname"><em>observables</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines latest emissions from current observable and other observables when any of them emits. The combining result is std::tuple&lt;...&gt;. </p>
<div class="image">
<object type="image/svg+xml" data="combine_latest.svg" style="pointer-events: none;"></object>
</div>
<p>Actually this operator subscribes on all of theses observables and emits <code>std::tuple</code> of last emissions when any of them emits new emission (and each observable emit values at least one to be able to provide combined value)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observables</td><td>are observables whose emissions would be combined with the current observable's emissions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the combine_latest operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="combine__latest_8hpp_source.html">rpp/operators/combine_latest.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line">    rpp::source::just(1, 2, 3)                                  <span class="comment">// source 1</span></div>
<div class="line">        .combine_latest(</div>
<div class="line">            [](<span class="keywordtype">int</span> left, <span class="keywordtype">int</span> right) { <span class="keywordflow">return</span> left + right; },   <span class="comment">// custom combiner</span></div>
<div class="line">            rpp::source::just(4, 5, 6))                         <span class="comment">// source 2</span></div>
<div class="line">        .subscribe(</div>
<div class="line">            [](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; <span class="stringliteral">&quot;-&quot;</span> &lt;&lt; v; },</div>
<div class="line">            [](<span class="keyword">const</span> std::exception_ptr&amp;) {},</div>
<div class="line">            []() { std::cout &lt;&lt; <span class="stringliteral">&quot;-|&quot;</span> &lt;&lt; std::endl; });</div>
<div class="line">    <span class="comment">// source 1:          -1---2---3-|</span></div>
<div class="line">    <span class="comment">// source 2: -4---5---6-| (note that source 2 is subscribed earlier than source 1)</span></div>
<div class="line">    <span class="comment">// Output  : -7-8-9-|</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Implementation details:</dt><dd><ul>
<li><b>On subscribe</b><ul>
<li>Allocates one <code>shared_ptr</code> to store last emissions.</li>
<li>Wraps subscriber with serialization logic to be sure callbacks called serialized</li>
</ul>
</li>
<li><b>OnNext</b><ul>
<li>Keeps last emission from each observable</li>
<li>Emits <code>std::tuple</code> of last emissions if there is last emissions for each observable</li>
</ul>
</li>
<li><b>OnError</b><ul>
<li>Just forwards original on_error</li>
</ul>
</li>
<li><b>OnCompleted</b><ul>
<li>Just forwards original on_completed</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/combinelatest.html">https://reactivex.io/documentation/operators/combinelatest.html</a> </dd></dl>

</div>
</div>
<a id="ga84ed0dcdeda6a4cb3a9871ab2817e114" name="ga84ed0dcdeda6a4cb3a9871ab2817e114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84ed0dcdeda6a4cb3a9871ab2817e114">&#9670;&#160;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;typename ... Args&gt; <br />
requires (is_header_included&lt;merge_tag, Args...&gt; &amp;&amp; <a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a>&lt;Type&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::merge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts observable of observables of items into observable of items via merging emissions. </p>
<dl class="section warning"><dt>Warning</dt><dd>According to observable contract (<a href="https://reactivex.io/documentation/contract.html">https://reactivex.io/documentation/contract.html</a>) emissions from any observable should be serialized, so, resulting observable uses mutex to satisfy this requirement</dd></dl>
<div class="image">
<object type="image/svg+xml" data="merge.svg" style="pointer-events: none;"></object>
</div>
<p>Actually it subscribes on each observable from emissions. Resulting observables completes when ALL observables completes</p>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the merge operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="merge_8hpp_source.html">rpp/operators/merge.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">    rpp::source::just(rpp::source::just(1).as_dynamic(),</div>
<div class="line">                      rpp::source::never&lt;int&gt;().as_dynamic(),</div>
<div class="line">                      rpp::source::just(2).as_dynamic())</div>
<div class="line">            .merge()</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; });</div>
<div class="line">    <span class="comment">// Output: 1 2</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Implementation details:</dt><dd><ul>
<li><b>On subscribe</b><ul>
<li>Allocates one <code>shared_ptr</code> to store interal state</li>
<li>Wraps subscriber with serialization logic to be sure callbacks called serialized</li>
</ul>
</li>
<li><b>OnNext for original observable</b><ul>
<li>Subscribes on obtained observable</li>
</ul>
</li>
<li><b>OnNext for inner observable</b><ul>
<li>Just forwards original on_next</li>
</ul>
</li>
<li><b>OnError</b><ul>
<li>Just forwards original on_error</li>
</ul>
</li>
<li><b>OnCompleted</b><ul>
<li>Just forwards original on_completed when all observables emit on_completed</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/merge.html">https://reactivex.io/documentation/operators/merge.html</a> </dd></dl>

</div>
</div>
<a id="gafa55b14eec1c6c40b8655e20c6edf5b2" name="gafa55b14eec1c6c40b8655e20c6edf5b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa55b14eec1c6c40b8655e20c6edf5b2">&#9670;&#160;</a></span>merge_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;constraint::observable_of_type&lt; Type &gt; ... TObservables&gt; <br />
requires (is_header_included&lt;merge_tag, TObservables...&gt;&amp;&amp; sizeof...(TObservables) &gt;= 1)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::merge_with </td>
          <td>(</td>
          <td class="paramtype">TObservables &amp;&amp;...&#160;</td>
          <td class="paramname"><em>observables</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines submissions from current observable with other observables into one. </p>
<dl class="section warning"><dt>Warning</dt><dd>According to observable contract (<a href="https://reactivex.io/documentation/contract.html">https://reactivex.io/documentation/contract.html</a>) emissions from any observable should be serialized, so, resulting observable uses mutex to satisfy this requirement</dd></dl>
<div class="image">
<object type="image/svg+xml" data="merge_with.svg" style="pointer-events: none;"></object>
</div>
<p>Actually it subscribes on each observable. Resulting observables completes when ALL observables completes</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observables</td><td>are observables whose emissions would be merged with current observable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the merge operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="merge_8hpp_source.html">rpp/operators/merge.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">    rpp::source::just(1)</div>
<div class="line">            .merge_with(rpp::source::just(2))</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; });</div>
<div class="line">    <span class="comment">// Output: 1 2</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Implementation details:</dt><dd><ul>
<li><b>On subscribe</b><ul>
<li>Allocates one <code>shared_ptr</code> to store interal state</li>
<li>Wraps subscriber with serialization logic to be sure callbacks called serialized</li>
</ul>
</li>
<li><b>OnNext</b><ul>
<li>Just forwards original on_next</li>
</ul>
</li>
<li><b>OnError</b><ul>
<li>Just forwards original on_error</li>
</ul>
</li>
<li><b>OnCompleted</b><ul>
<li>Just forwards original on_completed when all observables emit on_completed</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/merge.html">https://reactivex.io/documentation/operators/merge.html</a> </dd></dl>

</div>
</div>
<a id="gaf86bfdf7b2026804303f5b468fa22480" name="gaf86bfdf7b2026804303f5b468fa22480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf86bfdf7b2026804303f5b468fa22480">&#9670;&#160;</a></span>start_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;constraint::observable_of_type&lt; Type &gt; ... TObservables&gt; <br />
requires is_header_included&lt;start_with_tag, TObservables...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::start_with </td>
          <td>(</td>
          <td class="paramtype">TObservables &amp;&amp;...&#160;</td>
          <td class="paramname"><em>observables_to_start_with</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines submissions from current observable with other observables into one but without overlapping and starting from observables provided as arguments. </p>
<div class="image">
<object type="image/svg+xml" data="start_with_observable.svg" style="pointer-events: none;"></object>
</div>
<p>Actually it makes concat(observables_to_start_with..., current_observable) so observables from argument subscribed before current observable</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observables</td><td>list of observables which should be used before current observable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the start_with operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="start__with_8hpp_source.html">rpp/operators/start_with.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">    rpp::source::just(1, 2, 3)</div>
<div class="line">        .start_with(rpp::source::just(5), rpp::source::just(6))</div>
<div class="line">        .subscribe([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; });</div>
<div class="line">    <span class="comment">// Output: 5 6 1 2 3</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/startwith.html">https://reactivex.io/documentation/operators/startwith.html</a> </dd></dl>

</div>
</div>
<a id="gaced47c11cd4cea804a6d0f7c33be2fa0" name="gaced47c11cd4cea804a6d0f7c33be2fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaced47c11cd4cea804a6d0f7c33be2fa0">&#9670;&#160;</a></span>start_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;rpp::memory_model memory_model = memory_model::use_stack, constraint::decayed_same_as&lt; Type &gt; ... TTypes&gt; <br />
requires is_header_included&lt;start_with_tag, TTypes...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::start_with </td>
          <td>(</td>
          <td class="paramtype">TTypes &amp;&amp;...&#160;</td>
          <td class="paramname"><em>vals_to_start_with</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines submissions from current observable with values into one but without overlapping and starting from values provided as arguments. </p>
<div class="image">
<object type="image/svg+xml" data="start_with.svg" style="pointer-events: none;"></object>
</div>
<p>Actually it makes concat(rpp::source::just(vals_to_start_with)..., current_observable) so observables from argument subscribed before current observable</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">memory_model</td><td>memory_model strategy used to store provided values </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vals</td><td>list of values which should be emitted before current observable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the start_with operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="start__with_8hpp_source.html">rpp/operators/start_with.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">    rpp::source::just(1,2,3)</div>
<div class="line">        .start_with(5, 6)</div>
<div class="line">        .subscribe([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; });</div>
<div class="line">    <span class="comment">// Output: 5 6 1 2 3</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/startwith.html">https://reactivex.io/documentation/operators/startwith.html</a> </dd></dl>

</div>
</div>
<a id="ga2e3a232da875328d9d53adf7a30c25cf" name="ga2e3a232da875328d9d53adf7a30c25cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e3a232da875328d9d53adf7a30c25cf">&#9670;&#160;</a></span>switch_on_next()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;typename ... Args&gt; <br />
requires (is_header_included&lt;switch_on_next_tag, Args...&gt;&amp;&amp; <a class="el" href="conceptrpp_1_1constraint_1_1observable.html">rpp::constraint::observable</a>&lt;Type&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::switch_on_next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts observable of observables into observable of values which emits values from most recent underlying observable till new observable obtained. </p>
<div class="image">
<object type="image/svg+xml" data="switch_on_next.svg" style="pointer-events: none;"></object>
</div>
<p>Actually this operator just unsubscribes from previous observable and subscribes on new observable when obtained in <code>on_next</code></p>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the switch_on_next operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="switch__on__next_8hpp_source.html">rpp/operators/switch_on_next.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Example:</dt><dd><div class="fragment"><div class="line">    rpp::source::just(rpp::source::just(1).as_dynamic(),</div>
<div class="line">                      rpp::source::never&lt;int&gt;().as_dynamic(),</div>
<div class="line">                      rpp::source::just(2).as_dynamic())</div>
<div class="line">            .switch_on_next()</div>
<div class="line">            .subscribe([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; });</div>
<div class="line">    <span class="comment">// Output: 1 2</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Implementation details:</dt><dd><ul>
<li><b>On subscribe</b><ul>
<li>Allocates one <code>shared_ptr</code> to store internal state</li>
</ul>
</li>
<li><b>OnNext</b><ul>
<li>Unsubscribed from previous observable (if any)</li>
<li>Subscribed on new emitted observable</li>
</ul>
</li>
<li><b>OnError</b><ul>
<li>Just forwards original on_error</li>
</ul>
</li>
<li><b>OnCompleted</b><ul>
<li>Just forwards original on_completed if no any active inner observable or original observable yet</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/switch.html">https://reactivex.io/documentation/operators/switch.html</a> </dd></dl>

</div>
</div>
<a id="ga4ea21b87312c2789a9fac07aca6037ed" name="ga4ea21b87312c2789a9fac07aca6037ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ea21b87312c2789a9fac07aca6037ed">&#9670;&#160;</a></span>with_latest_from() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;constraint::observable ... TObservables&gt; <br />
requires is_header_included&lt;with_latest_from_tag, TObservables...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::with_latest_from </td>
          <td>(</td>
          <td class="paramtype">TObservables &amp;&amp;...&#160;</td>
          <td class="paramname"><em>observables</em></td><td>)</td>
          <td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines latest emissions from observables with emission from current observable when it sends new value via making tuple. </p>
<div class="image">
<object type="image/svg+xml" data="with_latest_from.svg" style="pointer-events: none;"></object>
</div>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">observables</td><td>are observables whose emissions would be combined when current observable sends new value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the with_latest_from operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="with__latest__from_8hpp_source.html">rpp/operators/with_latest_from.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line">    rpp::source::just(1, 2, 3)</div>
<div class="line">        .with_latest_from(rpp::source::just(3, 4, 5, 6))</div>
<div class="line">        .subscribe([](std::tuple&lt;int,int&gt; v) { std::cout &lt;&lt; std::get&lt;0&gt;(v) &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; std::get&lt;1&gt;(v) &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; });</div>
<div class="line">    <span class="comment">// Output: 1:6 2:6 3:6</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/combinelatest.html">https://reactivex.io/documentation/operators/combinelatest.html</a> </dd></dl>

</div>
</div>
<a id="ga805656c8847d81ace55ebc71d0598e44" name="ga805656c8847d81ace55ebc71d0598e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga805656c8847d81ace55ebc71d0598e44">&#9670;&#160;</a></span>with_latest_from() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;constraint::decayed_type Type, typename SpecificObservable &gt; </div>
<div class="memtemplate">
template&lt;constraint::observable ... TObservables, std::invocable&lt; Type, utils::extract_observable_type_t&lt; TObservables &gt;... &gt; TSelector&gt; <br />
requires is_header_included&lt;with_latest_from_tag, TObservables...&gt;</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structrpp_1_1details_1_1member__overload.html">observable</a>::with_latest_from </td>
          <td>(</td>
          <td class="paramtype">TSelector &amp;&amp;&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TObservables &amp;&amp;...&#160;</td>
          <td class="paramname"><em>observables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines latest emissions from observables with emission from current observable when it sends new value via applying selector. </p>
<div class="image">
<object type="image/svg+xml" data="with_latest_from_custom_selector.svg" style="pointer-events: none;"></object>
</div>
<p>Actually this operator just keeps last values from all other observables and combines them together with each new emission from original observable</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>is applied to current emission of current observable and latests emissions from observables </td></tr>
    <tr><td class="paramname">observables</td><td>are observables whose emissions would be combined when current observable sends new value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new <a class="el" href="classrpp_1_1specific__observable.html" title="Type-full observable (or typed) that has the notion of Type and upstream observables for C++ compiler...">specific_observable</a> with the with_latest_from operator as most recent operator. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>#include &lt;<a class="el" href="with__latest__from_8hpp_source.html">rpp/operators/with_latest_from.hpp</a>&gt;</dd></dl>
<dl class="section user"><dt>Examples</dt><dd><div class="fragment"><div class="line">    rpp::source::just(1, 2, 3)</div>
<div class="line">        .with_latest_from([](<span class="keywordtype">int</span> left, <span class="keywordtype">int</span> right) { <span class="keywordflow">return</span> left + right; },</div>
<div class="line">                          rpp::source::just(3, 4, 5, 6))</div>
<div class="line">        .subscribe([](<span class="keywordtype">int</span> v) { std::cout &lt;&lt; v &lt;&lt; <span class="stringliteral">&quot; &quot;</span>; });</div>
<div class="line">    <span class="comment">// Output: 7 8 9</span></div>
</div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Implementation details:</dt><dd><ul>
<li><b>On subscribe</b><ul>
<li>Allocates one <code>shared_ptr</code> to keep last values from all observables</li>
</ul>
</li>
<li><b>OnNext for original observable</b><ul>
<li>Applies selector to new emission and all saved last values from other observable (if any value for all observables)</li>
</ul>
</li>
<li><b>OnNext other original observables</b><ul>
<li>Just updates last value for this observable</li>
</ul>
</li>
<li><b>OnError</b><ul>
<li>Just forwards original on_error</li>
</ul>
</li>
<li><b>OnCompleted for original observable</b><ul>
<li>Just forwards original on_completed</li>
</ul>
</li>
<li><b>OnCompleted for other observables</b><ul>
<li>None</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="https://reactivex.io/documentation/operators/combinelatest.html">https://reactivex.io/documentation/operators/combinelatest.html</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
