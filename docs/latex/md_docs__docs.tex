\label{md_docs__docs_docs}%
\Hypertarget{md_docs__docs_docs}%

\begin{DoxyItemize}
\item \doxylink{quick_start}{Quick Start} -\/ fast overview how to work with RPP
\item \doxylink{advanced}{Advanced Guide} -\/ everything about RPP in details
\item \doxylink{why_rpp}{Why Reactive\+Plus\+Plus?} -\/ why Reactive\+Plus\+Plus?
\item \doxylink{specific_vs_dynamic}{Performance vs Flexibility\+: Specific vs Dynamic} -\/ overview of the concept of {\ttfamily specific\+\_\+} and {\ttfamily dynamic\+\_\+} types used in {\bfseries{RPP}} and how it affects performance
\item \doxylink{memory_model}{Memory Model} -\/ overview of new concept used in RPP related to copy/move/heap usage for objects passed inside RPP
\item \doxylink{exception_guarantee}{Exception guarantee} -\/ overview of exception guarantees provided by RPP
\item \doxylink{status}{Implementation status} -\/ current implementation status 
\end{DoxyItemize}\hypertarget{quick_start}{}\doxysection{Quick Start}\label{quick_start}
\label{quick_start_md_docs_Quick_Start}%
\Hypertarget{quick_start_md_docs_Quick_Start}%
 \hypertarget{quick_start_autotoc_md22}{}\doxysubsection{Brief workflow}\label{quick_start_autotoc_md22}
For the brief overview of the Reactive pattern read \href{https://reactivex.io/}{\texttt{ https\+://reactivex.\+io/}}.

In short, creation of programs with help of Reactive\+Plus\+Plus split into several parts\+:\hypertarget{quick_start_autotoc_md23}{}\doxysubsubsection{1) Define observables}\label{quick_start_autotoc_md23}
Observables are sources of your future streams. First of all you need to create some observable which emits values. You can select from some \href{https://victimsnino.github.io/ReactivePlusPlus/docs/html/group__creational__operators.html}{\texttt{ predefined}} or built your own.

For example, 
\begin{DoxyCode}{0}
\DoxyCodeLine{rpp::source::from\_callable(\&::getchar)}

\end{DoxyCode}
 observable which emits one char from {\ttfamily cin} via invoking of provided function once after subscription

Action inside observable happens ONLY after subscription on this observable and ONLY for provided subscriber/observer. It means, that you can subscribe on the same observable multiple times! But actually each of this subscriber would see its \char`\"{}own\char`\"{} observable -\/ function invoked especially for this one.\hypertarget{quick_start_autotoc_md24}{}\doxysubsubsection{2) Chain observable}\label{quick_start_autotoc_md24}
When you have some source of data you need to extend it somehow to make it useful! For example, let\textquotesingle{}s make it infinite instead of emitting one value\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{rpp::source::from\_callable(\&::getchar)}
\DoxyCodeLine{\ \ \ .repeat()}

\end{DoxyCode}


Also we can filters out digits, transform rest chars to upper. We need to add


\begin{DoxyCode}{0}
\DoxyCodeLine{...}
\DoxyCodeLine{.filter(std::not\_fn(\&::isdigit))}
\DoxyCodeLine{.map(\&::toupper)}

\end{DoxyCode}
 How long do we want to obtain values? let\textquotesingle{}s say, till \textquotesingle{}0\textquotesingle{} char. 
\begin{DoxyCode}{0}
\DoxyCodeLine{...}
\DoxyCodeLine{.take\_while([](\textcolor{keywordtype}{char}\ v)\ \{\ \textcolor{keywordflow}{return}\ v\ !=\ \textcolor{charliteral}{'0'};\ \})}
\DoxyCodeLine{.filter(std::not\_fn(\&::isdigit))}
\DoxyCodeLine{.map(\&::toupper)}

\end{DoxyCode}
\hypertarget{quick_start_autotoc_md25}{}\doxysubsubsection{3) Subscription}\label{quick_start_autotoc_md25}
What we want to do with resulting values? Let\textquotesingle{}s dump it to console. Resulting code looks like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{rpp::source::from\_callable(\&::getchar)}
\DoxyCodeLine{\ \ \ \ .repeat()}
\DoxyCodeLine{\ \ \ \ .take\_while([](\textcolor{keywordtype}{char}\ v)\ \{\ \textcolor{keywordflow}{return}\ v\ !=\ \textcolor{charliteral}{'0'};\ \})}
\DoxyCodeLine{\ \ \ \ .filter(std::not\_fn(\&::isdigit))}
\DoxyCodeLine{\ \ \ \ .map(\&::toupper)}
\DoxyCodeLine{\ \ \ \ .subscribe([](\textcolor{keywordtype}{char}\ v)\ \{\ std::cout\ <<\ v;\ \});}

\end{DoxyCode}
 Subscribe function applies any from\+:
\begin{DoxyItemize}
\item \mbox{[}none\mbox{]}
\item subscription
\item {\ttfamily on\+\_\+next}
\item subscription, {\ttfamily on\+\_\+next}
\item {\ttfamily on\+\_\+next}, {\ttfamily on\+\_\+error}
\item subscription, {\ttfamily on\+\_\+next}, {\ttfamily on\+\_\+error}
\item {\ttfamily on\+\_\+next}, {\ttfamily on\+\_\+completed}
\item subscription, {\ttfamily on\+\_\+next}, {\ttfamily on\+\_\+completed}
\item on\+\_\+next{\ttfamily ,}on\+\_\+erroron\+\_\+completed{\ttfamily }
\item {\ttfamily subscription,}on\+\_\+next{\ttfamily ,}on\+\_\+erroron\+\_\+completed\`{}
\item observer
\item subscription, observer 
\end{DoxyItemize}\hypertarget{advanced}{}\doxysection{Advanced Guide}\label{advanced}
\label{advanced_md_docs_Advanced}%
\Hypertarget{advanced_md_docs_Advanced}%
 \hypertarget{advanced_autotoc_md0}{}\doxysubsection{Beforehand}\label{advanced_autotoc_md0}
Before hand, please, read \doxylink{specific_vs_dynamic}{Performance vs Flexibility\+: Specific vs Dynamic}

Also read this one\+: \href{https://reactivex.io/documentation/contract.html}{\texttt{ Contract}}

Let\textquotesingle{}s review this one in details\+: \begin{quote}
Observables must issue notifications to observers serially (not in parallel). They may issue these notifications from different threads, but there must be a formal happens-\/before relationship between the notifications. \end{quote}
It means, that\+:


\begin{DoxyEnumerate}
\item All operators implemented in RPP are following this contract and emissions from observables/operators built-\/in in RPP are serialized
\item All logic inside operator\textquotesingle{}s callbacks and observer can be not thread-\/safe due to thread-\/safety is guaranteed. (for example, {\ttfamily take} operator doesn\textquotesingle{}t use mutexes or atomics due to underlying observable {\bfseries{MUST}} emit items serialized)
\item When you implement your own operator via {\ttfamily create} be careful to {\bfseries{follow this contract}}!
\item it is true {\bfseries{EXCEPT FOR}} subjects if they are used manually due to users can use subjects for its own purposes there is potentially place for breaking this concept. Be careful and use synchronized subjects!
\end{DoxyEnumerate}

It means, that for example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto}\ s1\ =\ rpp::source::just(1).repeat().subscribe\_on(\mbox{\hyperlink{classrpp_1_1schedulers_1_1new__thread}{rpp::schedulers::new\_thread}}\{\});}
\DoxyCodeLine{\textcolor{keyword}{auto}\ s2\ =\ rpp::source::just(2).repeat().subscribe\_on(\mbox{\hyperlink{classrpp_1_1schedulers_1_1new__thread}{rpp::schedulers::new\_thread}}\{\});}
\DoxyCodeLine{s1.merge\_with(s2).map([](\textcolor{keywordtype}{int}\ v)\{}
\DoxyCodeLine{\ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}enter\ "{}}\ <<\ v\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \ std::this\_thread::sleep\_for(std::chrono::seconds\{1\});}
\DoxyCodeLine{\ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}exit\ "{}}\ <<\ v\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ v;}
\DoxyCodeLine{\}).as\_blocking().subscribe([](\textcolor{keywordtype}{int})\{\});}

\end{DoxyCode}
 will never produce something like 
\begin{DoxyCode}{0}
\DoxyCodeLine{enter\ 1}
\DoxyCodeLine{enter\ 2}
\DoxyCodeLine{exit\ 2}
\DoxyCodeLine{exit\ 1}

\end{DoxyCode}
 only serialized 
\begin{DoxyCode}{0}
\DoxyCodeLine{enter\ 1}
\DoxyCodeLine{exit\ 1}
\DoxyCodeLine{enter\ 1}
\DoxyCodeLine{exit\ 1}
\DoxyCodeLine{enter\ 2}
\DoxyCodeLine{exit\ 2}
\DoxyCodeLine{enter\ 2}
\DoxyCodeLine{exit\ 2}

\end{DoxyCode}
\hypertarget{advanced_autotoc_md1}{}\doxysubsection{Observable}\label{advanced_autotoc_md1}
Observables are just wrappers over callback function with ability to be extended via operators. Everytime you apply some operator to observable, observable is copied (or moved). As a result, whole its state is copied/moved too\+:


\begin{DoxyItemize}
\item be ready for it, so, your callback (or any state inside operators) should be cheap enough to copy
\item if you want to avoid it, you can convert your observable to dynamic\+: it forces to move observable to {\ttfamily shared\+\_\+ptr}, as a result, no any future copies/moves
\item some observables/operators have {\ttfamily memory\+\_\+model} (\doxylink{memory_model}{Memory Model}) parameter to change strategy of handling your variable\+: keep to copy/move or move to shared\+\_\+ptr once
\end{DoxyItemize}

Everytime you subscribe subscriber observable just invokes callback for this subscriber and nothing else. It means, that actually observable do nothing and doesn\textquotesingle{}t emit values, {\bfseries{callback emits values}}.

To achieve better performance use {\ttfamily specific\+\_\+observable} while it is possible. Same for the argument of callback (for example, when you use {\ttfamily rpp\+::source\+::create})\+: use {\ttfamily const auto\&} for subscriber to avoid implicit conversion to dynamic subscriber.

By default, functional programming deals with immutable data and \char`\"{}pure functions\char`\"{}. Observable follows this principle, so, it can accept only const functions for callback. \hypertarget{advanced_autotoc_md2}{}\doxysubsection{Observers}\label{advanced_autotoc_md2}
Observer also follows this principle, so, it can accept only const functions for callbacks.\hypertarget{advanced_autotoc_md3}{}\doxysubsection{Operators}\label{advanced_autotoc_md3}
For better compilation speed each operator placed in each own header. Due to great desire to have dot operations inside observable, observable inherits implementation of operators via {\ttfamily member\+\_\+overload} hack\+: it forwards interface, but implementation placed in another file. It looks like wide-\/spread separation to cpp/hpp files.\hypertarget{advanced_autotoc_md4}{}\doxysubsection{Subscriber}\label{advanced_autotoc_md4}
Subscriber is just wrapper over observer with subscription. Everytime callback received, subscriber checks for subscription state and emits value to observer if subscription is still active. \hypertarget{why_rpp}{}\doxysection{Why Reactive\+Plus\+Plus?}\label{why_rpp}
\label{why_rpp_md_docs_WhyRpp}%
\Hypertarget{why_rpp_md_docs_WhyRpp}%
 \hypertarget{why_rpp_autotoc_md29}{}\doxysubsection{What about existing Reactive Extension libraries for C++?}\label{why_rpp_autotoc_md29}
Reactive programming is excelent programming paradigm and approach for creation of multi-\/threading and real-\/time programs which reacts on some events. Unfortunately, there is only one stable and fully-\/implemented library at the moment of creation of Reactive\+Plus\+Plus -\/ \href{https://github.com/ReactiveX/RxCpp}{\texttt{ Rx\+Cpp}}.

\href{https://github.com/ReactiveX/RxCpp}{\texttt{ Rx\+Cpp}} is great and awesome library and perfect implementation of ReactiveX approach. However Rx\+Cpp has some disadvantages\+:
\begin{DoxyItemize}
\item It is a bit $\ast$$\ast$\char`\"{}old\char`\"{} library written in C++11$\ast$$\ast$ with some parts written in the {\bfseries{pre-\/\+C++11 style}} (mess of old-\/style classes and wrappers)
\item {\bfseries{Issue}} with {\bfseries{template parameters}}\+: {\ttfamily rxcpp\+::observable} contains {\bfseries{full chain of operators}} as second template parameter... where each operator has a bunch of another template parameters itself. It forces {\bfseries{IDEs}} works {\bfseries{slower}} while parsing resulting type of observable. Also it forces to generate {\bfseries{heavier binaries and debug symbols and slower build time}}.
\item It has high perfomance cost due to tremendous amount of usage of heap.
\item Some parts of code written with non-\/effective logic (e.\+g. {\ttfamily timeout} operator -\/ rpp version faster in about 17000-\/25000\%...)
\end{DoxyItemize}

Another implementation of RX for c++\+: \href{https://github.com/CODIANZ/another-rxcpp}{\texttt{ another-\/rxcpp}}. It partly solves issues of Rx\+Cpp via {\bfseries{eliminating of template parameter}} with help of {\bfseries{type-\/erasing}} and making each callback as {\ttfamily std\+::function}. As a result issue with templates resvoled, but this approach has disadvantages related to runtime\+: resulting size of observers/observables becomes greater due to heavy {\ttfamily std\+::function} object, usage of heap for storing everything causes perfomance issues, implementation is just pretty simple and provides a lot of copies of passed objects.\hypertarget{why_rpp_autotoc_md30}{}\doxysubsection{Why Reactive\+Plus\+Plus?}\label{why_rpp_autotoc_md30}
{\bfseries{Reactive\+Plus\+Plus}} tries to solve all mentioned issues\+:
\begin{DoxyItemize}
\item {\bfseries{Reactive\+Plus\+Plus}} written in {\bfseries{Modern C++ (C++20)}} with concepts which makes code-\/base a lot more understandable and clean\+:
\begin{DoxyItemize}
\item Concepts provide more clear errors and checks\+: you will understand that pass something incorrect before compilation in IDE or during compilation with understandable errors instead of \+\_\+\char`\"{}invalid template class map\+\_\+invalid\+\_\+t\char`\"{}\+\_\+
\item Everywhere while possible used deduction of template arguments, for example, type of values of observable by type of subscriber used in on\+\_\+subscribe and etc
\end{DoxyItemize}
\item {\bfseries{Reactive\+Plus\+Plus}} keeps balance between performance and type-\/erasing mechanism\+: Read about it in \href{https://victimsnino.github.io/ReactivePlusPlus/docs/html/specific_vs_dynamic.html}{\texttt{ $\ast$$\ast$"{}Performance vs Flexibility\+: Specific vs Dynamic"{}$\ast$$\ast$}}
\item {\bfseries{Reactive\+Plus\+Plus}} is fast\+: every part of code written with perfomance in mind. Starting from tests over amount of copies/move and finishing to Continous Benchmarking. Benchmarks prove that RPP faster than Rx\+CPP in most cases\+: \href{https://victimsnino.github.io/ReactivePlusPlus/benchmark}{\texttt{ Continous benchmarking results}} (check timeout operator comparison ;-\/)) 
\end{DoxyItemize}\hypertarget{specific_vs_dynamic}{}\doxysection{Performance vs Flexibility\+: Specific vs Dynamic}\label{specific_vs_dynamic}
\label{specific_vs_dynamic_md_docs_Specific_vs_Dynamic}%
\Hypertarget{specific_vs_dynamic_md_docs_Specific_vs_Dynamic}%
 \hypertarget{specific_vs_dynamic_autotoc_md26}{}\doxysubsection{Brief overview}\label{specific_vs_dynamic_autotoc_md26}
In general Reactive Extensions can be split into three main parts from the objects perspective\+:
\begin{DoxyItemize}
\item observable
\item observer
\item subscriber
\end{DoxyItemize}

Each of this objects obtains user-\/defined callbacks to call when some event happens (on\+\_\+subscribe, on\+\_\+next/on\+\_\+error/on\+\_\+completed and etc). To store it in C++ we have two ways with its own prons and cons\+:
\begin{DoxyItemize}
\item store it explicitly via template type
\begin{DoxyItemize}
\item \doxygenemoji{\+:heavy\+\_\+check\+\_\+mark\+:}{heavy_check_mark} No heap allocations
\item \doxygenemoji{\+:heavy\+\_\+check\+\_\+mark\+:}{heavy_check_mark} Fast invoking (with possible inlining)
\item \doxygenemoji{\+:x\+:}{x} Template parameter makes each instance \char`\"{}uniq\char`\"{}
\item \doxygenemoji{\+:x\+:}{x} No way to store it somehow in containers/class members without pain
\end{DoxyItemize}
\item use type-\/erasure mechanism
\begin{DoxyItemize}
\item \doxygenemoji{\+:heavy\+\_\+check\+\_\+mark\+:}{heavy_check_mark} Avoiding of template parameters
\item \doxygenemoji{\+:heavy\+\_\+check\+\_\+mark\+:}{heavy_check_mark} Easy to store in containers/class members/input arguments of functions
\item \doxygenemoji{\+:x\+:}{x} In most cases heap allocation during constrution
\item \doxygenemoji{\+:x\+:}{x} More usage of memory even for cheap objects (std\+::function or pointer to allocated type)
\item \doxygenemoji{\+:x\+:}{x} Indirect invoking (most probably via pointer or virtual functions)
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{specific_vs_dynamic_autotoc_md27}{}\doxysubsection{Reactive\+Plus\+Plus solution}\label{specific_vs_dynamic_autotoc_md27}
Reactive\+Plus\+Plus provides ability to use both of this ways to make usage experience optimal! Each of mentioned above core parts has two different specifications\+: {\ttfamily specific\+\_\+} and {\ttfamily dynamic\+\_\+}.

{\ttfamily specific\+\_\+} is default specialization which uses fully template approach to have best performance and memory consumption\+: each callback/used type specific as template parameter of this class {\ttfamily dynamic\+\_\+} specialization uses type-\/erasure mechanism with all resulting peformance and memory hits, but this specialization is useful if you want to store type as class member or place it inside containers and etc.

There detailed list with explanations\+:
\begin{DoxyItemize}
\item observables\+:
\begin{DoxyItemize}
\item \href{https://victimsnino.github.io/ReactivePlusPlus/docs/html/classrpp_1_1specific__observable.html}{\texttt{ rpp\+::specific\+\_\+observable$<$\+T, On\+Subscribe\+Fn$>$}} -\/ Stores type of {\ttfamily on\+\_\+subscribe} callback explicitly via {\ttfamily On\+Subscribe} template type. Due to explicit type of callback such an observable can obtains ANY specialization of subscriber and ANY specialization of observers without construction of {\ttfamily dynamic\+\_\+} specializations
\item \href{https://victimsnino.github.io/ReactivePlusPlus/docs/html/classrpp_1_1dynamic__observable.html}{\texttt{ rpp\+::dynamic\+\_\+observable$<$\+T$>$}} -\/ stores callback as shared\+\_\+ptr to base class of {\ttfamily \doxylink{classrpp_1_1specific__observable}{rpp\+::specific\+\_\+observable}} and calling callback via virtual function. Due to this limitation this observable can obtain only {\ttfamily dynamic\+\_\+observer} and {\ttfamily dynamic\+\_\+subscriber}
\end{DoxyItemize}
\item observers
\begin{DoxyItemize}
\item \href{https://victimsnino.github.io/ReactivePlusPlus/docs/html/classrpp_1_1specific__observer.html}{\texttt{ rpp\+::specific\+\_\+observer$<$\+T, On\+Next, On\+Error, On\+Completed$>$}} -\/ Stores types of {\ttfamily on\+\_\+next, on\+\_\+error and on\+\_\+completed} callbacks explicitly via {\ttfamily On\+Next, On\+Error, On\+Completed} template types.
\item \href{https://victimsnino.github.io/ReactivePlusPlus/docs/html/classrpp_1_1dynamic__observer.html}{\texttt{ rpp\+::dynamic\+\_\+observer$<$\+T$>$}} -\/ stores callbacks as shared\+\_\+ptr to base class of {\ttfamily \doxylink{classrpp_1_1specific__observer}{rpp\+::specific\+\_\+observer}} and calling callbacks via virtual functions.
\end{DoxyItemize}
\item subscribers\+:
\begin{DoxyItemize}
\item \href{https://victimsnino.github.io/ReactivePlusPlus/docs/html/classrpp_1_1specific__subscriber.html}{\texttt{ rpp\+::specific\+\_\+subscriber$<$\+T, Observer$>$}} -\/ stores explicit underlying type of observer as {\ttfamily Observer} template type to avoid construction of \href{https://victimsnino.github.io/ReactivePlusPlus/docs/html/classrpp_1_1dynamic__observer.html}{\texttt{ rpp\+::dynamic\+\_\+observer}}.
\item \href{https://victimsnino.github.io/ReactivePlusPlus/docs/html/classrpp_1_1dynamic__subscriber.html}{\texttt{ rpp\+::dynamic\+\_\+subscriber$<$\+T$>$}} -\/ uses \href{https://victimsnino.github.io/ReactivePlusPlus/docs/html/classrpp_1_1dynamic__observer.html}{\texttt{ rpp\+::dynamic\+\_\+observer}} type as underlying type for observer.
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{specific_vs_dynamic_autotoc_md28}{}\doxysubsection{Examples}\label{specific_vs_dynamic_autotoc_md28}
So, to achieve best performance avoid usage of {\ttfamily dynamic\+\_\+} specialization till you really need it or you want to avoid extra copies/moves of original objects captured inside callbacks and prefer one-\/time {\ttfamily shared\+\_\+ptr} allication instead. For example, 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto}\ observable\ =\ rpp::observable::create<int>([](\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ subscriber)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ subscriber.on\_next(1);}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{auto}\ observer\ =\ \mbox{\hyperlink{classrpp_1_1specific__observer}{rpp::specific\_observer}}\{[](\textcolor{keywordtype}{int}\ v)\{\ std::cout\ <<\ v;\}\};}
\DoxyCodeLine{observable.subscribe(observer);}
\DoxyCodeLine{\textcolor{comment}{//\ OR\ observable.subscribe([](int\ v)\{\ std::cout\ <<\ v;\});}}

\end{DoxyCode}
 uses only {\bfseries{ONE heap allocation}} for {\ttfamily rpp\+::subscription} inside subscriber to store subscription state and no any other allocation happens. On the other hand 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{//1\ dynamic\_subscriber\ in\ observable}}
\DoxyCodeLine{\textcolor{keyword}{auto}\ observable\ =\ rpp::observable::create<int>([](\textcolor{keyword}{const}\ \mbox{\hyperlink{classrpp_1_1dynamic__subscriber}{rpp::dynamic\_subscriber<int>}}\&\ subscriber)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ subscriber.on\_next(1);}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{observable.subscribe(\mbox{\hyperlink{classrpp_1_1specific__observer}{rpp::specific\_observer}}\{[](\textcolor{keywordtype}{int}\ v)\{\ std::cout\ <<\ v;\}\});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//2\ dynamic\_observable}}
\DoxyCodeLine{\mbox{\hyperlink{classrpp_1_1dynamic__observable}{rpp::dynamic\_observable}}\ observable\ =\ rpp::observable::create<int>([](\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ subscriber)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ subscriber.on\_next(1);}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{observable.subscribe(\mbox{\hyperlink{classrpp_1_1specific__observer}{rpp::specific\_observer}}\{[](\textcolor{keywordtype}{int}\ v)\{\ std::cout\ <<\ v;\}\});}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//3\ dynamic\_observer}}
\DoxyCodeLine{\textcolor{keyword}{auto}\ observable\ =\ rpp::observable::create<int>([](\textcolor{keyword}{const}\ \textcolor{keyword}{auto}\&\ subscriber)}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ subscriber.on\_next(1);}
\DoxyCodeLine{\});}
\DoxyCodeLine{}
\DoxyCodeLine{observable.subscribe(\mbox{\hyperlink{classrpp_1_1dynamic__observer}{rpp::dynamic\_observer}}\{[](\textcolor{keywordtype}{int}\ v)\{\ std::cout\ <<\ v;\}\});}

\end{DoxyCode}


all this samples uses extra heap allocations\+:
\begin{DoxyEnumerate}
\item explicitly specify type of subscriber inside observable as {\ttfamily dynamic\+\_\+} -\/\texorpdfstring{$>$}{>} {\ttfamily dynamic\+\_\+subscriber} created during {\ttfamily subscribe(...)} call which creates {\ttfamily dynamic\+\_\+observer} underhood -\/\texorpdfstring{$>$}{>} heap used to construct {\ttfamily dynamic\+\_\+observer}
\item {\ttfamily dynamic\+\_\+observable} constructed via heap allocation. This specizalization can obtain only {\ttfamily dynamic\+\_\+subscriber} -\/\texorpdfstring{$>$}{>} same as prev. example
\item {\ttfamily dynamic\+\_\+observer} constructed via heap allocation.
\end{DoxyEnumerate}

For detailed comparison of performance of different operations for {\ttfamily specific\+\_\+} and {\ttfamily dynamic\+\_\+} you can find in \href{https://victimsnino.github.io/ReactivePlusPlus/benchmark}{\texttt{ Continuous Benchmarking}} \hypertarget{memory_model}{}\doxysection{Memory Model}\label{memory_model}
\label{memory_model_md_docs_MemoryModel}%
\Hypertarget{memory_model_md_docs_MemoryModel}%
\hypertarget{memory_model_autotoc_md20}{}\doxysubsection{Overview}\label{memory_model_autotoc_md20}
In Reactive\+Plus\+Plus there is new concept unique for this implementation\+: rpp\+::memory\+\_\+model\+:

Some of the operators and sources like {\ttfamily rpp\+::source\+::just} or {\ttfamily rpp\+::operators\+::start\+\_\+with} accepts user\textquotesingle{}s variables for usage. Some of this types can be such an expensive to copy or move and it would be preferable to copy it once to heap, but some other types (like POD) are cheap enough and usage of heap would be overkill. But these variables should be saved inside somehow!

So, RPP provides ability to select strategy \char`\"{}how to deal with such a variables\char`\"{} via {\ttfamily rpp\+::memory\+\_\+model} enum.\hypertarget{memory_model_autotoc_md21}{}\doxysubsection{Examples}\label{memory_model_autotoc_md21}
For example, {\ttfamily rpp\+::source\+::just}


\begin{DoxyCode}{0}
\DoxyCodeLine{rpp::source::just(my\_custom\_variable);}

\end{DoxyCode}
 by default {\ttfamily just} uses {\ttfamily rpp\+::memory\+\_\+model\+::use\+\_\+stack} and {\ttfamily my\+\_\+custom\+\_\+variable} would be copied and moved everywhere when needed. On the other hand


\begin{DoxyCode}{0}
\DoxyCodeLine{rpp::source::just<rpp::memory\_model::use\_shared>(my\_custom\_variable);}

\end{DoxyCode}
 makes only 1 copy/move to shared\+\_\+ptr and then uses it instead.

As a a result, users can select preferable way of handling of their types. \hypertarget{exception_guarantee}{}\doxysection{Exception guarantee}\label{exception_guarantee}
\label{exception_guarantee_md_docs_Exception_Guarantee}%
\Hypertarget{exception_guarantee_md_docs_Exception_Guarantee}%
 \hypertarget{exception_guarantee_autotoc_md6}{}\doxysubsection{Overview}\label{exception_guarantee_autotoc_md6}
In non-\/reactive programming functions/modules throws exception in case of something invalid. As a result, user can catch it and handle it somehow while internal state of objects can be in some state (invalid/untouched/partly valid) and etc.

In reactive programming there is another way of exception mechanism\+: throwing exception as is from original place is useless. Notification about \char`\"{}something goes wrong\char`\"{} need to receive observer/subscriber, not owner of callstack. As a result, ANY exception obtained during emitting items and etc WOULD be delivered to subscriber/observer via {\ttfamily on\+\_\+error} function and then unsubscribe happens. As a result, no any raw exceptions would be throws during using RPP. In case of emitting {\ttfamily on\+\_\+error} whole internal state of observable keeps valid but it doesn\textquotesingle{}t matter -\/ whole chain would be destroyed due to {\ttfamily on\+\_\+error} forces unsubscribe. Reactive catching mechanisms like {\ttfamily catch} or {\ttfamily retry} {\bfseries{re-\/subscribes}} on observable. it means, that new chain with new states would be created, not re-\/used existing one. \hypertarget{status}{}\doxysection{Implementation status}\label{status}
\label{status_md_docs_Implementation_Status}%
\Hypertarget{status_md_docs_Implementation_Status}%
 \hypertarget{status_autotoc_md7}{}\doxysubsection{Fundamentals}\label{status_autotoc_md7}

\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} Observables
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} Specific Observable
\item \mbox{[}x\mbox{]} Dynamic Observable
\item \mbox{[}x\mbox{]} Blocking Observable
\item \mbox{[}x\mbox{]} Connectable Observable
\end{DoxyItemize}
\item \mbox{[}x\mbox{]} Observers
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} Specific Observer
\item \mbox{[}x\mbox{]} Dynamic Observer
\end{DoxyItemize}
\item \mbox{[}x\mbox{]} Subscribers
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} Specific Subscriber
\item \mbox{[}x\mbox{]} Dynamic Subscriber
\end{DoxyItemize}
\item \mbox{[}x\mbox{]} Subscriptions
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} Composite Subscription
\item \mbox{[}x\mbox{]} Callback Subscription
\end{DoxyItemize}
\item \mbox{[} \mbox{]} Schedulers
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} Immediate
\item \mbox{[}x\mbox{]} New Thread
\item \mbox{[}x\mbox{]} Current\+Thread/\+Trampoline
\item \mbox{[}x\mbox{]} Run\+Loop
\item \mbox{[} \mbox{]} Event\+Loop
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{status_autotoc_md8}{}\doxysubsection{Creating Observables}\label{status_autotoc_md8}

\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} Create
\item \mbox{[}x\mbox{]} Just
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} + memory\+\_\+model
\end{DoxyItemize}
\item \mbox{[}x\mbox{]} empty/never/error
\item \mbox{[} \mbox{]} from
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} iterable
\item \mbox{[} \mbox{]} future
\item \mbox{[} \mbox{]} promise
\item \mbox{[}x\mbox{]} callable
\item \mbox{[} \mbox{]} async
\end{DoxyItemize}
\item \mbox{[} \mbox{]} defer
\item \mbox{[}x\mbox{]} interval
\item \mbox{[} \mbox{]} range
\item \mbox{[} \mbox{]} repeat
\item \mbox{[} \mbox{]} timer
\end{DoxyItemize}\hypertarget{status_autotoc_md9}{}\doxysubsection{Operators}\label{status_autotoc_md9}
\hypertarget{status_autotoc_md10}{}\doxysubsubsection{Transforming}\label{status_autotoc_md10}

\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} map
\item \mbox{[}x\mbox{]} group\+\_\+by
\item \mbox{[}x\mbox{]} flat\+\_\+map
\item \mbox{[}x\mbox{]} scan
\item \mbox{[} \mbox{]} buffer
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} count
\begin{DoxyItemize}
\item \mbox{[} \mbox{]} skip
\end{DoxyItemize}
\item \mbox{[} \mbox{]} time
\item \mbox{[} \mbox{]} time\+\_\+or\+\_\+count
\end{DoxyItemize}
\item \mbox{[} \mbox{]} window
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} count
\begin{DoxyItemize}
\item \mbox{[} \mbox{]} skip
\end{DoxyItemize}
\item \mbox{[} \mbox{]} time
\item \mbox{[} \mbox{]} time\+\_\+or\+\_\+count
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{status_autotoc_md11}{}\doxysubsubsection{Filtering}\label{status_autotoc_md11}

\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} filter
\item \mbox{[}x\mbox{]} take
\item \mbox{[}x\mbox{]} debounce
\item \mbox{[} \mbox{]} distinct
\begin{DoxyItemize}
\item \mbox{[} \mbox{]} distinct
\item \mbox{[}x\mbox{]} distinct\+\_\+until\+\_\+changed
\end{DoxyItemize}
\item \mbox{[} \mbox{]} element\+\_\+at
\item \mbox{[}x\mbox{]} first
\item \mbox{[} \mbox{]} ignore\+\_\+elements
\item \mbox{[}x\mbox{]} last
\item \mbox{[} \mbox{]} sample
\begin{DoxyItemize}
\item \mbox{[} \mbox{]} sample (observable)
\item \mbox{[}x\mbox{]} sample\+\_\+with\+\_\+time
\end{DoxyItemize}
\item \mbox{[}x\mbox{]} skip
\item \mbox{[} \mbox{]} skip\+\_\+last
\item \mbox{[}x\mbox{]} take\+\_\+last
\end{DoxyItemize}\hypertarget{status_autotoc_md12}{}\doxysubsubsection{Conditional}\label{status_autotoc_md12}

\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} take\+\_\+while
\item \mbox{[} \mbox{]} all
\item \mbox{[} \mbox{]} amb
\item \mbox{[} \mbox{]} contains
\item \mbox{[} \mbox{]} default\+\_\+if\+\_\+empty
\item \mbox{[} \mbox{]} sequence\+\_\+equal
\item \mbox{[} \mbox{]} skip\+\_\+until
\item \mbox{[} \mbox{]} skip\+\_\+while
\item \mbox{[}x\mbox{]} take\+\_\+until
\end{DoxyItemize}\hypertarget{status_autotoc_md13}{}\doxysubsubsection{Combining}\label{status_autotoc_md13}

\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} merge
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} observable of observables
\item \mbox{[}x\mbox{]} merge with
\item \mbox{[} \mbox{]} merge delay error
\end{DoxyItemize}
\item \mbox{[} \mbox{]} switch
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} switch\+\_\+map
\item \mbox{[}x\mbox{]} switch\+\_\+on\+\_\+next
\item \mbox{[} \mbox{]} switch\+\_\+if\+\_\+empty
\end{DoxyItemize}
\item \mbox{[}x\mbox{]} with\+\_\+latest\+\_\+from
\item \mbox{[}x\mbox{]} start\+\_\+with
\item \mbox{[}x\mbox{]} combine\+\_\+latest
\item \mbox{[} \mbox{]} zip
\end{DoxyItemize}\hypertarget{status_autotoc_md14}{}\doxysubsubsection{Aggregate}\label{status_autotoc_md14}

\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} average
\item \mbox{[}x\mbox{]} concat
\item \mbox{[}x\mbox{]} count
\item \mbox{[}x\mbox{]} max
\item \mbox{[}x\mbox{]} min
\item \mbox{[}x\mbox{]} reduce
\item \mbox{[}x\mbox{]} sum
\end{DoxyItemize}\hypertarget{status_autotoc_md15}{}\doxysubsubsection{Backpressure}\label{status_autotoc_md15}

\begin{DoxyItemize}
\item \mbox{[} \mbox{]} backpressure ???
\end{DoxyItemize}\hypertarget{status_autotoc_md16}{}\doxysubsubsection{Error handling}\label{status_autotoc_md16}

\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} catch
\item \mbox{[} \mbox{]} retry
\end{DoxyItemize}\hypertarget{status_autotoc_md17}{}\doxysubsubsection{Utility}\label{status_autotoc_md17}

\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} observe\+\_\+on
\item \mbox{[}x\mbox{]} repeat
\begin{DoxyItemize}
\item \mbox{[} \mbox{]} scheduling (by default trampoline ?)
\end{DoxyItemize}
\item \mbox{[}x\mbox{]} subscribe\+\_\+on
\item \mbox{[}x\mbox{]} delay
\item \mbox{[}x\mbox{]} do/tap
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} tap with observer
\item \mbox{[}x\mbox{]} tap with callbacks
\item \mbox{[}x\mbox{]} do\+\_\+on\+\_\+next
\item \mbox{[}x\mbox{]} do\+\_\+on\+\_\+error
\item \mbox{[}x\mbox{]} do\+\_\+on\+\_\+completed
\end{DoxyItemize}
\item \mbox{[}x\mbox{]} timeout
\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} timeout
\item \mbox{[}x\mbox{]} timeout with fallback observable
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{status_autotoc_md18}{}\doxysubsubsection{Connectable}\label{status_autotoc_md18}

\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} publish
\item \mbox{[}x\mbox{]} multicast
\item \mbox{[}x\mbox{]} connect
\item \mbox{[}x\mbox{]} ref\+\_\+count
\item \mbox{[} \mbox{]} replay
\end{DoxyItemize}\hypertarget{status_autotoc_md19}{}\doxysubsection{Subjects}\label{status_autotoc_md19}

\begin{DoxyItemize}
\item \mbox{[}x\mbox{]} publish\+\_\+subject
\item \mbox{[}x\mbox{]} behavior\+\_\+subject
\item \mbox{[} \mbox{]} serialized\+\_\+subject
\item \mbox{[} \mbox{]} replay\+\_\+subject
\item \mbox{[} \mbox{]} async\+\_\+subject 
\end{DoxyItemize}