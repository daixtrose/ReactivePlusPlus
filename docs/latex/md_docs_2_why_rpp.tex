\hypertarget{md_docs_2_why_rpp_autotoc_md29}{}\doxysection{What about existing Reactive Extension libraries for C++?}\label{md_docs_2_why_rpp_autotoc_md29}
Reactive programming is excelent programming paradigm and approach for creation of multi-\/threading and real-\/time programs which reacts on some events. Unfortunately, there is only one stable and fully-\/implemented library at the moment of creation of Reactive\+Plus\+Plus -\/ \href{https://github.com/ReactiveX/RxCpp}{\texttt{ Rx\+Cpp}}.

\href{https://github.com/ReactiveX/RxCpp}{\texttt{ Rx\+Cpp}} is great and awesome library and perfect implementation of ReactiveX approach. However Rx\+Cpp has some disadvantages\+:
\begin{DoxyItemize}
\item It is a bit $\ast$$\ast$\char`\"{}old\char`\"{} library written in C++11$\ast$$\ast$ with some parts written in the {\bfseries{pre-\/\+C++11 style}} (mess of old-\/style classes and wrappers)
\item {\bfseries{Issue}} with {\bfseries{template parameters}}\+: {\ttfamily rxcpp\+::observable} contains {\bfseries{full chain of operators}} as second template parameter... where each operator has a bunch of another template parameters itself. It forces {\bfseries{IDEs}} works {\bfseries{slower}} while parsing resulting type of observable. Also it forces to generate {\bfseries{heavier binaries and debug symbols and slower build time}}.
\item It has high perfomance cost due to tremendous amount of usage of heap.
\item Some parts of code written with non-\/effective logic (e.\+g. {\ttfamily timeout} operator -\/ rpp version faster in about 17000-\/25000\%...)
\end{DoxyItemize}

Another implementation of RX for c++\+: \href{https://github.com/CODIANZ/another-rxcpp}{\texttt{ another-\/rxcpp}}. It partly solves issues of Rx\+Cpp via {\bfseries{eliminating of template parameter}} with help of {\bfseries{type-\/erasing}} and making each callback as {\ttfamily std\+::function}. As a result issue with templates resvoled, but this approach has disadvantages related to runtime\+: resulting size of observers/observables becomes greater due to heavy {\ttfamily std\+::function} object, usage of heap for storing everything causes perfomance issues, implementation is just pretty simple and provides a lot of copies of passed objects.\hypertarget{md_docs_2_why_rpp_autotoc_md30}{}\doxysection{Why Reactive\+Plus\+Plus?}\label{md_docs_2_why_rpp_autotoc_md30}
{\bfseries{Reactive\+Plus\+Plus}} tries to solve all mentioned issues\+:
\begin{DoxyItemize}
\item {\bfseries{Reactive\+Plus\+Plus}} written in {\bfseries{Modern C++ (C++20)}} with concepts which makes code-\/base a lot more understandable and clean\+:
\begin{DoxyItemize}
\item Concepts provide more clear errors and checks\+: you will understand that pass something incorrect before compilation in IDE or during compilation with understandable errors instead of \+\_\+\char`\"{}invalid template class map\+\_\+invalid\+\_\+t\char`\"{}\+\_\+
\item Everywhere while possible used deduction of template arguments, for example, type of values of observable by type of subscriber used in on\+\_\+subscribe and etc
\end{DoxyItemize}
\item {\bfseries{Reactive\+Plus\+Plus}} keeps balance between performance and type-\/erasing mechanism\+: Read about it in \href{https://victimsnino.github.io/ReactivePlusPlus/docs/html/specific_vs_dynamic.html}{\texttt{ $\ast$$\ast$"{}Performance vs Flexibility\+: Specific vs Dynamic"{}$\ast$$\ast$}}
\item {\bfseries{Reactive\+Plus\+Plus}} is fast\+: every part of code written with perfomance in mind. Starting from tests over amount of copies/move and finishing to Continous Benchmarking. Benchmarks prove that RPP faster than Rx\+CPP in most cases\+: \href{https://victimsnino.github.io/ReactivePlusPlus/benchmark}{\texttt{ Continous benchmarking results}} (check timeout operator comparison ;-\/)) 
\end{DoxyItemize}