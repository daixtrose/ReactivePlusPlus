\hypertarget{from_8hpp_source}{}\doxysection{from.\+hpp}
\label{from_8hpp_source}\index{src/rpp/rpp/sources/from.hpp@{src/rpp/rpp/sources/from.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{//                  ReactivePlusPlus library}}
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{//          Copyright Aleksey Loginov 2022 -\/ present.}}
\DoxyCodeLine{4 \textcolor{comment}{// Distributed under the Boost Software License, Version 1.0.}}
\DoxyCodeLine{5 \textcolor{comment}{//    (See accompanying file LICENSE\_1\_0.txt or copy at}}
\DoxyCodeLine{6 \textcolor{comment}{//          https://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{7 \textcolor{comment}{//}}
\DoxyCodeLine{8 \textcolor{comment}{// Project home: https://github.com/victimsnino/ReactivePlusPlus}}
\DoxyCodeLine{9 \textcolor{comment}{//}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <rpp/memory\_model.hpp>}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <rpp/schedulers/immediate\_scheduler.hpp>}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <rpp/sources/create.hpp>}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <rpp/sources/fwd.hpp>}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <rpp/utils/utilities.hpp>}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <rpp/operators/map.hpp>}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <rpp/utils/function\_traits.hpp>}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <rpp/defs.hpp>}}
\DoxyCodeLine{21 }
\DoxyCodeLine{22 }
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include <array>}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#include <ranges>}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{26 }
\DoxyCodeLine{27 IMPLEMENTATION\_FILE(just\_tag);}
\DoxyCodeLine{28 IMPLEMENTATION\_FILE(from\_tag);}
\DoxyCodeLine{29 }
\DoxyCodeLine{30 \textcolor{keyword}{namespace }rpp::observable::details}
\DoxyCodeLine{31 \{}
\DoxyCodeLine{32 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{33 \textcolor{keyword}{auto} extract\_iterable\_from\_packed(\textcolor{keyword}{const} T \& v) -\/> \textcolor{keyword}{const} \textcolor{keyword}{auto}\&}
\DoxyCodeLine{34 \{}
\DoxyCodeLine{35     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::ranges::range<T>)}
\DoxyCodeLine{36         \textcolor{keywordflow}{return} v;}
\DoxyCodeLine{37     \textcolor{keywordflow}{else}}
\DoxyCodeLine{38         \textcolor{keywordflow}{return} *v;}
\DoxyCodeLine{39 \}}
\DoxyCodeLine{40 }
\DoxyCodeLine{41 \textcolor{keywordtype}{void} iterate(\textcolor{keyword}{auto}\&\&                                        iterable,}
\DoxyCodeLine{42              \textcolor{keyword}{const} schedulers::constraint::scheduler \textcolor{keyword}{auto}\& scheduler,}
\DoxyCodeLine{43              constraint::subscriber \textcolor{keyword}{auto}\&\&                 subscriber)}
\DoxyCodeLine{44 \{}
\DoxyCodeLine{45     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (constraint::decayed\_same\_as<\textcolor{keyword}{decltype}(scheduler), schedulers::immediate>)}
\DoxyCodeLine{46     \{}
\DoxyCodeLine{47         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& v : extract\_iterable\_from\_packed(iterable))}
\DoxyCodeLine{48         \{}
\DoxyCodeLine{49             \textcolor{keywordflow}{if} (subscriber.is\_subscribed())}
\DoxyCodeLine{50                 subscriber.on\_next(utils::as\_const(v));}
\DoxyCodeLine{51             \textcolor{keywordflow}{else}}
\DoxyCodeLine{52                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{53         \}}
\DoxyCodeLine{54         subscriber.on\_completed();}
\DoxyCodeLine{55     \}}
\DoxyCodeLine{56     \textcolor{keywordflow}{else}}
\DoxyCodeLine{57     \{}
\DoxyCodeLine{58         \textcolor{keyword}{auto} worker = scheduler.create\_worker(subscriber.get\_subscription());}
\DoxyCodeLine{59         worker.schedule([iterable=std::forward<\textcolor{keyword}{decltype}(iterable)>(iterable), }
\DoxyCodeLine{60                          subscriber=std::forward<\textcolor{keyword}{decltype}(subscriber)>(subscriber), }
\DoxyCodeLine{61                          index = \textcolor{keywordtype}{size\_t}\{0\}]() mutable-\/> schedulers::optional\_duration}
\DoxyCodeLine{62         \{            }
\DoxyCodeLine{63             \textcolor{keywordflow}{try}}
\DoxyCodeLine{64             \{}
\DoxyCodeLine{65                 \textcolor{keyword}{const} \textcolor{keyword}{auto}\& extracted\_iterable = extract\_iterable\_from\_packed(iterable);}
\DoxyCodeLine{66                 \textcolor{keyword}{const} \textcolor{keyword}{auto}  end = std::cend(extracted\_iterable);}
\DoxyCodeLine{67                 \textcolor{keyword}{auto}        itr = std::cbegin(extracted\_iterable);}
\DoxyCodeLine{68 }
\DoxyCodeLine{69                 std::ranges::advance(itr, \textcolor{keyword}{static\_cast<}int64\_t\textcolor{keyword}{>}(index), end);}
\DoxyCodeLine{70 }
\DoxyCodeLine{71                 \textcolor{keywordflow}{if} (itr != end)}
\DoxyCodeLine{72                 \{}
\DoxyCodeLine{73                     subscriber.on\_next(utils::as\_const(*itr));}
\DoxyCodeLine{74                     \textcolor{keywordflow}{if} (std::next(itr) != end) \textcolor{comment}{// it was not last}}
\DoxyCodeLine{75                     \{}
\DoxyCodeLine{76                         ++index;}
\DoxyCodeLine{77                         \textcolor{keywordflow}{return} schedulers::duration\{\}; \textcolor{comment}{// re-\/schedule this}}
\DoxyCodeLine{78                     \}}
\DoxyCodeLine{79                 \}}
\DoxyCodeLine{80 }
\DoxyCodeLine{81                 subscriber.on\_completed();}
\DoxyCodeLine{82             \}}
\DoxyCodeLine{83             \textcolor{keywordflow}{catch}(...)}
\DoxyCodeLine{84             \{}
\DoxyCodeLine{85                 subscriber.on\_error(std::current\_exception());}
\DoxyCodeLine{86             \}}
\DoxyCodeLine{87             \textcolor{keywordflow}{return} std::nullopt;}
\DoxyCodeLine{88 }
\DoxyCodeLine{89         \});}
\DoxyCodeLine{90     \}}
\DoxyCodeLine{91 \}}
\DoxyCodeLine{92 }
\DoxyCodeLine{93 \textcolor{keyword}{template}<memory\_model memory\_model, std::ranges::range Container, \textcolor{keyword}{typename} ...Ts>}
\DoxyCodeLine{94 \textcolor{keyword}{auto} pack\_to\_container(Ts\&\& ...items)}
\DoxyCodeLine{95 \{}
\DoxyCodeLine{96     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (memory\_model == memory\_model::use\_stack)}
\DoxyCodeLine{97         \textcolor{keywordflow}{return} Container\{std::forward<Ts>(items)...\};}
\DoxyCodeLine{98     \textcolor{keywordflow}{else}}
\DoxyCodeLine{99         \textcolor{comment}{// raw new call to avoid extra copy/moves for items}}
\DoxyCodeLine{100         \textcolor{keywordflow}{return} std::shared\_ptr<Container>(\textcolor{keyword}{new} Container\{std::forward<Ts>(items)...\});}
\DoxyCodeLine{101 \}}
\DoxyCodeLine{102 }
\DoxyCodeLine{103 \textcolor{keyword}{template}<memory\_model memory\_model, constraint::decayed\_type T, \textcolor{keyword}{typename} ...Ts>}
\DoxyCodeLine{104 \textcolor{keyword}{auto} pack\_variadic(Ts\&\& ...items)}
\DoxyCodeLine{105 \{}
\DoxyCodeLine{106     \textcolor{keywordflow}{return} pack\_to\_container<memory\_model, std::array<T, \textcolor{keyword}{sizeof}...(Ts)>>(std::forward<Ts>(items)...);}
\DoxyCodeLine{107 \}}
\DoxyCodeLine{108 }
\DoxyCodeLine{109 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PackedIterable, schedulers::constra\textcolor{keywordtype}{int}::scheduler TScheduler>}
\DoxyCodeLine{110 \textcolor{keyword}{class }\mbox{\hyperlink{classrpp_1_1observable_1_1details_1_1iterate__impl}{iterate\_impl}}}
\DoxyCodeLine{111 \{}
\DoxyCodeLine{112 \textcolor{keyword}{public}:}
\DoxyCodeLine{113     \mbox{\hyperlink{classrpp_1_1observable_1_1details_1_1iterate__impl}{iterate\_impl}}(\textcolor{keyword}{const} PackedIterable\& iterable, \textcolor{keyword}{const} TScheduler\& scheduler)}
\DoxyCodeLine{114         : m\_iterable\{iterable\}}
\DoxyCodeLine{115         , m\_scheduler\{scheduler\} \{\}}
\DoxyCodeLine{116 }
\DoxyCodeLine{117     \mbox{\hyperlink{classrpp_1_1observable_1_1details_1_1iterate__impl}{iterate\_impl}}(PackedIterable\&\& iterable, \textcolor{keyword}{const} TScheduler\& scheduler)}
\DoxyCodeLine{118         : m\_iterable\{std::move(iterable)\}}
\DoxyCodeLine{119         , m\_scheduler\{scheduler\} \{\}}
\DoxyCodeLine{120 }
\DoxyCodeLine{121     \textcolor{keyword}{template}<constra\textcolor{keywordtype}{int}::subscriber TSub>}
\DoxyCodeLine{122     \textcolor{keywordtype}{void} operator()(TSub\&\& subscriber) \textcolor{keyword}{const} \&}
\DoxyCodeLine{123     \{}
\DoxyCodeLine{124         details::iterate(m\_iterable, m\_scheduler, std::forward<TSub>(subscriber));}
\DoxyCodeLine{125     \}}
\DoxyCodeLine{126 }
\DoxyCodeLine{127     \textcolor{keyword}{template}<constra\textcolor{keywordtype}{int}::subscriber TSub>}
\DoxyCodeLine{128     \textcolor{keywordtype}{void} operator()(TSub\&\& subscriber) \textcolor{keyword}{const} \&\&}
\DoxyCodeLine{129     \{}
\DoxyCodeLine{130         details::iterate(std::move(m\_iterable), m\_scheduler, std::forward<TSub>(subscriber));}
\DoxyCodeLine{131     \}}
\DoxyCodeLine{132 }
\DoxyCodeLine{133 \textcolor{keyword}{private}:}
\DoxyCodeLine{134     \textcolor{keyword}{mutable} PackedIterable           m\_iterable;}
\DoxyCodeLine{135     RPP\_NO\_UNIQUE\_ADDRESS TScheduler m\_scheduler;}
\DoxyCodeLine{136 \};}
\DoxyCodeLine{137 \} \textcolor{comment}{// namespace rpp::observable::details}}
\DoxyCodeLine{138 }
\DoxyCodeLine{139 \textcolor{keyword}{namespace }rpp::observable}
\DoxyCodeLine{140 \{}
\DoxyCodeLine{163 \textcolor{keyword}{template}<memory\_model memory\_model \textcolor{comment}{/* = memory\_model::use\_stack */}, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} ...Ts>}
\DoxyCodeLine{164 \textcolor{keyword}{auto} just(\textcolor{keyword}{const} schedulers::constraint::scheduler \textcolor{keyword}{auto}\& scheduler, T\&\& item, Ts\&\& ...items) \textcolor{keyword}{requires} (rpp::details::is\_header\_included<rpp::details::just\_tag, T, Ts...> \&\& (constraint::decayed\_same\_as<T, Ts> \&\& ...))}
\DoxyCodeLine{165 \{}
\DoxyCodeLine{166     \textcolor{keywordflow}{return} create<std::decay\_t<T>>(\mbox{\hyperlink{classrpp_1_1observable_1_1details_1_1iterate__impl}{details::iterate\_impl}}\{details::pack\_variadic<memory\_model, std::decay\_t<T>>(std::forward<T>(item), std::forward<Ts>(items)...), scheduler \});}
\DoxyCodeLine{167 \}}
\DoxyCodeLine{168 }
\DoxyCodeLine{191 \textcolor{keyword}{template}<memory\_model memory\_model \textcolor{comment}{/* = memory\_model::use\_stack */}, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} ...Ts>}
\DoxyCodeLine{192 \textcolor{keyword}{auto} just(T\&\& item, Ts\&\& ...items) \textcolor{keyword}{requires} (rpp::details::is\_header\_included<rpp::details::just\_tag, T, Ts...> \&\& (constraint::decayed\_same\_as<T, Ts> \&\& ...))}
\DoxyCodeLine{193 \{}
\DoxyCodeLine{194     \textcolor{keywordflow}{return} just<memory\_model>(schedulers::immediate\{\}, std::forward<T>(item), std::forward<Ts>(items)...);}
\DoxyCodeLine{195 \}}
\DoxyCodeLine{196 }
\DoxyCodeLine{217 \textcolor{keyword}{template}<memory\_model memory\_model \textcolor{comment}{/* = memory\_model::use\_stack */}, schedulers::constraint::scheduler TScheduler \textcolor{comment}{/* = schedulers::immediate */}>}
\DoxyCodeLine{218 \textcolor{keyword}{auto} \mbox{\hyperlink{group__creational__operators_gaa10b9e881db7e4a1ba5dad86d48e5220}{from\_iterable}}(std::ranges::range \textcolor{keyword}{auto}\&\& iterable, \textcolor{keyword}{const} TScheduler\& scheduler \textcolor{comment}{/* = TScheduler\{\} */}) \textcolor{keyword}{requires} rpp::details::is\_header\_included<rpp::details::from\_tag, TScheduler >}
\DoxyCodeLine{219 \{}
\DoxyCodeLine{220     \textcolor{keyword}{using }Container = std::decay\_t<\textcolor{keyword}{decltype}(iterable)>;}
\DoxyCodeLine{221     \textcolor{keywordflow}{return} create<std::ranges::range\_value\_t<Container>>(details::iterate\_impl\{ details::pack\_to\_container<memory\_model, Container>(std::forward<\textcolor{keyword}{decltype}(iterable)>(iterable)), scheduler \});}
\DoxyCodeLine{222 \}}
\DoxyCodeLine{223 }
\DoxyCodeLine{240 \textcolor{keyword}{template}<memory\_model memory\_model \textcolor{comment}{/* = memory\_model::use\_stack */}>}
\DoxyCodeLine{241 \textcolor{keyword}{auto} \mbox{\hyperlink{group__creational__operators_ga52959b5368cc881f38a305a3b5e1ded3}{from\_callable}}(std::invocable<> \textcolor{keyword}{auto}\&\& callable) \textcolor{keyword}{requires} rpp::details::is\_header\_included<rpp::details::from\_tag, \textcolor{keyword}{decltype}(callable)>}
\DoxyCodeLine{242 \{}
\DoxyCodeLine{243     \textcolor{keyword}{auto} obs = just<memory\_model>(std::forward<\textcolor{keyword}{decltype}(callable)>(callable));}
\DoxyCodeLine{244 }
\DoxyCodeLine{245     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::same\_as<utils::decayed\_invoke\_result\_t<\textcolor{keyword}{decltype}(callable)>, \textcolor{keywordtype}{void}>)}
\DoxyCodeLine{246         \textcolor{keywordflow}{return} std::move(obs).map([](\textcolor{keyword}{const} \textcolor{keyword}{auto}\& fn) \{ fn(); \textcolor{keywordflow}{return} utils::none\{\};\});}
\DoxyCodeLine{247     \textcolor{keywordflow}{else}}
\DoxyCodeLine{248         \textcolor{keywordflow}{return} std::move(obs).map([](\textcolor{keyword}{const} \textcolor{keyword}{auto}\& fn) \{ \textcolor{keywordflow}{return} fn(); \});}
\DoxyCodeLine{249 \}}
\DoxyCodeLine{250 \} \textcolor{comment}{// namespace rpp::observable}}

\end{DoxyCode}
