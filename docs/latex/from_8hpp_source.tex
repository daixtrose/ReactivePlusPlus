\hypertarget{from_8hpp_source}{}\doxysection{from.\+hpp}
\label{from_8hpp_source}\index{src/rpp/rpp/sources/from.hpp@{src/rpp/rpp/sources/from.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{//                  ReactivePlusPlus library}}
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{//          Copyright Aleksey Loginov 2022 -\/ present.}}
\DoxyCodeLine{4 \textcolor{comment}{// Distributed under the Boost Software License, Version 1.0.}}
\DoxyCodeLine{5 \textcolor{comment}{//    (See accompanying file LICENSE\_1\_0.txt or copy at}}
\DoxyCodeLine{6 \textcolor{comment}{//          https://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{7 \textcolor{comment}{//}}
\DoxyCodeLine{8 \textcolor{comment}{// Project home: https://github.com/victimsnino/ReactivePlusPlus}}
\DoxyCodeLine{9 \textcolor{comment}{//}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <rpp/memory\_model.hpp>}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <rpp/schedulers/trampoline\_scheduler.hpp>}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <rpp/sources/create.hpp>}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <rpp/sources/fwd.hpp>}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <rpp/utils/utilities.hpp>}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <rpp/operators/map.hpp>}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <rpp/utils/function\_traits.hpp>}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <rpp/defs.hpp>}}
\DoxyCodeLine{21 }
\DoxyCodeLine{22 }
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include <array>}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{25 }
\DoxyCodeLine{26 IMPLEMENTATION\_FILE(just\_tag);}
\DoxyCodeLine{27 IMPLEMENTATION\_FILE(from\_tag);}
\DoxyCodeLine{28 }
\DoxyCodeLine{29 \textcolor{keyword}{namespace }rpp::observable::details}
\DoxyCodeLine{30 \{}
\DoxyCodeLine{31 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{32 \textcolor{keyword}{auto} extract\_iterable\_from\_packed(\textcolor{keyword}{const} T \& v) -\/> \textcolor{keyword}{const} \textcolor{keyword}{auto}\&}
\DoxyCodeLine{33 \{}
\DoxyCodeLine{34     \textcolor{keywordflow}{return} v;}
\DoxyCodeLine{35 \}}
\DoxyCodeLine{36 }
\DoxyCodeLine{37 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T>}
\DoxyCodeLine{38 \textcolor{keyword}{auto} extract\_iterable\_from\_packed(\textcolor{keyword}{const} std::shared\_ptr<T> \& v) -\/> \textcolor{keyword}{const} \textcolor{keyword}{auto}\&}
\DoxyCodeLine{39 \{}
\DoxyCodeLine{40     \textcolor{keywordflow}{return} *v;}
\DoxyCodeLine{41 \}}
\DoxyCodeLine{42 }
\DoxyCodeLine{43 \textcolor{keywordtype}{void} iterate(\textcolor{keyword}{auto}\&\&                                        iterable,}
\DoxyCodeLine{44              \textcolor{keyword}{const} schedulers::constraint::scheduler \textcolor{keyword}{auto}\& scheduler,}
\DoxyCodeLine{45              constraint::subscriber \textcolor{keyword}{auto}\&\&                 subscriber)}
\DoxyCodeLine{46 \{}
\DoxyCodeLine{47     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (constraint::decayed\_same\_as<\textcolor{keyword}{decltype}(scheduler), schedulers::immediate>)}
\DoxyCodeLine{48     \{}
\DoxyCodeLine{49         \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}\& v : extract\_iterable\_from\_packed(iterable))}
\DoxyCodeLine{50         \{}
\DoxyCodeLine{51             \textcolor{keywordflow}{if} (subscriber.is\_subscribed())}
\DoxyCodeLine{52                 subscriber.on\_next(utils::as\_const(v));}
\DoxyCodeLine{53             \textcolor{keywordflow}{else}}
\DoxyCodeLine{54                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{55         \}}
\DoxyCodeLine{56         subscriber.on\_completed();}
\DoxyCodeLine{57     \}}
\DoxyCodeLine{58     \textcolor{keywordflow}{else}}
\DoxyCodeLine{59     \{}
\DoxyCodeLine{60         \textcolor{keyword}{auto} worker = scheduler.create\_worker(subscriber.get\_subscription());}
\DoxyCodeLine{61         worker.schedule([iterable=std::forward<\textcolor{keyword}{decltype}(iterable)>(iterable), }
\DoxyCodeLine{62                          subscriber=std::forward<\textcolor{keyword}{decltype}(subscriber)>(subscriber), }
\DoxyCodeLine{63                          index = \textcolor{keywordtype}{size\_t}\{0\}]() mutable-\/> schedulers::optional\_duration}
\DoxyCodeLine{64         \{            }
\DoxyCodeLine{65             \textcolor{keywordflow}{try}}
\DoxyCodeLine{66             \{}
\DoxyCodeLine{67                 \textcolor{keyword}{const} \textcolor{keyword}{auto}\& extracted\_iterable = extract\_iterable\_from\_packed(iterable);}
\DoxyCodeLine{68                 \textcolor{keyword}{const} \textcolor{keyword}{auto}  end = std::cend(extracted\_iterable);}
\DoxyCodeLine{69                 \textcolor{keyword}{auto}        itr = std::cbegin(extracted\_iterable);}
\DoxyCodeLine{70 }
\DoxyCodeLine{71                 std::advance(itr, \textcolor{keyword}{static\_cast<}int64\_t\textcolor{keyword}{>}(index));}
\DoxyCodeLine{72 }
\DoxyCodeLine{73                 \textcolor{keywordflow}{if} (itr != end)}
\DoxyCodeLine{74                 \{}
\DoxyCodeLine{75                     subscriber.on\_next(utils::as\_const(*itr));}
\DoxyCodeLine{76                     \textcolor{keywordflow}{if} (std::next(itr) != end) \textcolor{comment}{// it was not last}}
\DoxyCodeLine{77                     \{}
\DoxyCodeLine{78                         ++index;}
\DoxyCodeLine{79                         \textcolor{keywordflow}{return} schedulers::duration\{\}; \textcolor{comment}{// re-\/schedule this}}
\DoxyCodeLine{80                     \}}
\DoxyCodeLine{81                 \}}
\DoxyCodeLine{82 }
\DoxyCodeLine{83                 subscriber.on\_completed();}
\DoxyCodeLine{84             \}}
\DoxyCodeLine{85             \textcolor{keywordflow}{catch}(...)}
\DoxyCodeLine{86             \{}
\DoxyCodeLine{87                 subscriber.on\_error(std::current\_exception());}
\DoxyCodeLine{88             \}}
\DoxyCodeLine{89             \textcolor{keywordflow}{return} std::nullopt;}
\DoxyCodeLine{90 }
\DoxyCodeLine{91         \});}
\DoxyCodeLine{92     \}}
\DoxyCodeLine{93 \}}
\DoxyCodeLine{94 }
\DoxyCodeLine{95 }
\DoxyCodeLine{96 }
\DoxyCodeLine{97 \textcolor{keyword}{template}<memory\_model memory\_model, constraint::iterable Container, \textcolor{keyword}{typename} ...Ts>}
\DoxyCodeLine{98 \textcolor{keyword}{auto} pack\_to\_container(Ts\&\& ...items)}
\DoxyCodeLine{99 \{}
\DoxyCodeLine{100     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (memory\_model == memory\_model::use\_stack)}
\DoxyCodeLine{101         \textcolor{keywordflow}{return} Container\{std::forward<Ts>(items)...\};}
\DoxyCodeLine{102     \textcolor{keywordflow}{else}}
\DoxyCodeLine{103         \textcolor{comment}{// raw new call to avoid extra copy/moves for items}}
\DoxyCodeLine{104         \textcolor{keywordflow}{return} std::shared\_ptr<Container>(\textcolor{keyword}{new} Container\{std::forward<Ts>(items)...\});}
\DoxyCodeLine{105 \}}
\DoxyCodeLine{106 }
\DoxyCodeLine{107 \textcolor{keyword}{template}<memory\_model memory\_model, constraint::decayed\_type T, \textcolor{keyword}{typename} ...Ts>}
\DoxyCodeLine{108 \textcolor{keyword}{auto} pack\_variadic(Ts\&\& ...items)}
\DoxyCodeLine{109 \{}
\DoxyCodeLine{110     \textcolor{keywordflow}{return} pack\_to\_container<memory\_model, std::array<T, \textcolor{keyword}{sizeof}...(Ts)>>(std::forward<Ts>(items)...);}
\DoxyCodeLine{111 \}}
\DoxyCodeLine{112 }
\DoxyCodeLine{113 \textcolor{keyword}{template}<\textcolor{keyword}{typename} PackedIterable, schedulers::constra\textcolor{keywordtype}{int}::scheduler TScheduler>}
\DoxyCodeLine{114 \textcolor{keyword}{class }\mbox{\hyperlink{classrpp_1_1observable_1_1details_1_1iterate__impl}{iterate\_impl}}}
\DoxyCodeLine{115 \{}
\DoxyCodeLine{116 \textcolor{keyword}{public}:}
\DoxyCodeLine{117     \mbox{\hyperlink{classrpp_1_1observable_1_1details_1_1iterate__impl}{iterate\_impl}}(\textcolor{keyword}{const} PackedIterable\& iterable, \textcolor{keyword}{const} TScheduler\& scheduler)}
\DoxyCodeLine{118         : m\_iterable\{iterable\}}
\DoxyCodeLine{119         , m\_scheduler\{scheduler\} \{\}}
\DoxyCodeLine{120 }
\DoxyCodeLine{121     \mbox{\hyperlink{classrpp_1_1observable_1_1details_1_1iterate__impl}{iterate\_impl}}(PackedIterable\&\& iterable, \textcolor{keyword}{const} TScheduler\& scheduler)}
\DoxyCodeLine{122         : m\_iterable\{std::move(iterable)\}}
\DoxyCodeLine{123         , m\_scheduler\{scheduler\} \{\}}
\DoxyCodeLine{124 }
\DoxyCodeLine{125     \textcolor{keyword}{template}<constra\textcolor{keywordtype}{int}::subscriber TSub>}
\DoxyCodeLine{126     \textcolor{keywordtype}{void} operator()(TSub\&\& subscriber) \textcolor{keyword}{const} \&}
\DoxyCodeLine{127     \{}
\DoxyCodeLine{128         details::iterate(m\_iterable, m\_scheduler, std::forward<TSub>(subscriber));}
\DoxyCodeLine{129     \}}
\DoxyCodeLine{130 }
\DoxyCodeLine{131     \textcolor{keyword}{template}<constra\textcolor{keywordtype}{int}::subscriber TSub>}
\DoxyCodeLine{132     \textcolor{keywordtype}{void} operator()(TSub\&\& subscriber) \textcolor{keyword}{const} \&\&}
\DoxyCodeLine{133     \{}
\DoxyCodeLine{134         details::iterate(std::move(m\_iterable), m\_scheduler, std::forward<TSub>(subscriber));}
\DoxyCodeLine{135     \}}
\DoxyCodeLine{136 }
\DoxyCodeLine{137 \textcolor{keyword}{private}:}
\DoxyCodeLine{138     \textcolor{keyword}{mutable} PackedIterable           m\_iterable;}
\DoxyCodeLine{139     RPP\_NO\_UNIQUE\_ADDRESS TScheduler m\_scheduler;}
\DoxyCodeLine{140 \};}
\DoxyCodeLine{141 \} \textcolor{comment}{// namespace rpp::observable::details}}
\DoxyCodeLine{142 }
\DoxyCodeLine{143 \textcolor{keyword}{namespace }rpp::observable}
\DoxyCodeLine{144 \{}
\DoxyCodeLine{167 \textcolor{keyword}{template}<memory\_model memory\_model \textcolor{comment}{/* = memory\_model::use\_stack */}, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} ...Ts>}
\DoxyCodeLine{168 \textcolor{keyword}{auto} just(\textcolor{keyword}{const} \mbox{\hyperlink{conceptrpp_1_1schedulers_1_1constraint_1_1scheduler}{schedulers::constraint::scheduler}} \textcolor{keyword}{auto}\& scheduler, T\&\& item, Ts\&\& ...items) \textcolor{keyword}{requires} (rpp::details::is\_header\_included<rpp::details::just\_tag, T, Ts...> \&\& (constraint::decayed\_same\_as<T, Ts> \&\& ...))}
\DoxyCodeLine{169 \{}
\DoxyCodeLine{170     \textcolor{keywordflow}{return} create<std::decay\_t<T>>(\mbox{\hyperlink{classrpp_1_1observable_1_1details_1_1iterate__impl}{details::iterate\_impl}}\{details::pack\_variadic<memory\_model, std::decay\_t<T>>(std::forward<T>(item), std::forward<Ts>(items)...), scheduler \});}
\DoxyCodeLine{171 \}}
\DoxyCodeLine{172 }
\DoxyCodeLine{195 \textcolor{keyword}{template}<memory\_model memory\_model \textcolor{comment}{/* = memory\_model::use\_stack */}, \textcolor{keyword}{typename} T, \textcolor{keyword}{typename} ...Ts>}
\DoxyCodeLine{196 \textcolor{keyword}{auto} just(T\&\& item, Ts\&\& ...items) \textcolor{keyword}{requires} (rpp::details::is\_header\_included<rpp::details::just\_tag, T, Ts...> \&\& (constraint::decayed\_same\_as<T, Ts> \&\& ...))}
\DoxyCodeLine{197 \{}
\DoxyCodeLine{198     \textcolor{keywordflow}{return} just<memory\_model>(schedulers::trampoline\{\}, std::forward<T>(item), std::forward<Ts>(items)...);}
\DoxyCodeLine{199 \}}
\DoxyCodeLine{200 }
\DoxyCodeLine{221 \textcolor{keyword}{template}<memory\_model memory\_model \textcolor{comment}{/* = memory\_model::use\_stack */}, schedulers::constraint::scheduler TScheduler \textcolor{comment}{/* = schedulers::trampoline */}>}
\DoxyCodeLine{222 \textcolor{keyword}{auto} \mbox{\hyperlink{group__creational__operators_gaf796daac1f2e2450818dc95230946f54}{from\_iterable}}(constraint::iterable \textcolor{keyword}{auto}\&\& iterable, \textcolor{keyword}{const} TScheduler\& scheduler \textcolor{comment}{/* = TScheduler\{\} */}) \textcolor{keyword}{requires} rpp::details::is\_header\_included<rpp::details::from\_tag, TScheduler >}
\DoxyCodeLine{223 \{}
\DoxyCodeLine{224     \textcolor{keyword}{using }Container = std::decay\_t<\textcolor{keyword}{decltype}(iterable)>;}
\DoxyCodeLine{225     \textcolor{keywordflow}{return} create<utils::iterable\_value\_t<Container>>(details::iterate\_impl\{ details::pack\_to\_container<memory\_model, Container>(std::forward<\textcolor{keyword}{decltype}(iterable)>(iterable)), scheduler \});}
\DoxyCodeLine{226 \}}
\DoxyCodeLine{227 }
\DoxyCodeLine{244 \textcolor{keyword}{template}<memory\_model memory\_model \textcolor{comment}{/* = memory\_model::use\_stack */}>}
\DoxyCodeLine{245 \textcolor{keyword}{auto} \mbox{\hyperlink{group__creational__operators_ga52959b5368cc881f38a305a3b5e1ded3}{from\_callable}}(std::invocable<> \textcolor{keyword}{auto}\&\& callable) \textcolor{keyword}{requires} rpp::details::is\_header\_included<rpp::details::from\_tag, \textcolor{keyword}{decltype}(callable)>}
\DoxyCodeLine{246 \{}
\DoxyCodeLine{247     \textcolor{keyword}{auto} obs = just<memory\_model>(std::forward<\textcolor{keyword}{decltype}(callable)>(callable));}
\DoxyCodeLine{248 }
\DoxyCodeLine{249     \textcolor{keywordflow}{if} \textcolor{keyword}{constexpr} (std::same\_as<utils::decayed\_invoke\_result\_t<\textcolor{keyword}{decltype}(callable)>, \textcolor{keywordtype}{void}>)}
\DoxyCodeLine{250         \textcolor{keywordflow}{return} std::move(obs).map([](\textcolor{keyword}{const} \textcolor{keyword}{auto}\& fn) \{ fn(); \textcolor{keywordflow}{return} utils::none\{\};\});}
\DoxyCodeLine{251     \textcolor{keywordflow}{else}}
\DoxyCodeLine{252         \textcolor{keywordflow}{return} std::move(obs).map([](\textcolor{keyword}{const} \textcolor{keyword}{auto}\& fn) \{ \textcolor{keywordflow}{return} fn(); \});}
\DoxyCodeLine{253 \}}
\DoxyCodeLine{254 \} \textcolor{comment}{// namespace rpp::observable}}

\end{DoxyCode}
