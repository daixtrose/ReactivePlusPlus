\hypertarget{combine__latest_8hpp_source}{}\doxysection{combine\+\_\+latest.\+hpp}
\label{combine__latest_8hpp_source}\index{src/rpp/rpp/operators/combine\_latest.hpp@{src/rpp/rpp/operators/combine\_latest.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{//                  ReactivePlusPlus library}}
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{//          Copyright Aleksey Loginov 2022 -\/ present.}}
\DoxyCodeLine{4 \textcolor{comment}{//                    TC Wang 2022 -\/ present.}}
\DoxyCodeLine{5 \textcolor{comment}{// Distributed under the Boost Software License, Version 1.0.}}
\DoxyCodeLine{6 \textcolor{comment}{//    (See accompanying file LICENSE\_1\_0.txt or copy at}}
\DoxyCodeLine{7 \textcolor{comment}{//          https://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{8 \textcolor{comment}{//}}
\DoxyCodeLine{9 \textcolor{comment}{// Project home: https://github.com/victimsnino/ReactivePlusPlus}}
\DoxyCodeLine{10 \textcolor{comment}{//}}
\DoxyCodeLine{11 }
\DoxyCodeLine{12 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <rpp/defs.hpp>}                                    \textcolor{comment}{// RPP\_NO\_UNIQUE\_ADDRESS}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <rpp/operators/lift.hpp>}                          \textcolor{comment}{// required due to operator uses lift}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <rpp/operators/merge.hpp>}                         \textcolor{comment}{// merge\_state}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <rpp/operators/details/subscriber\_with\_state.hpp>} \textcolor{comment}{// create\_subscriber\_with\_state}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <rpp/operators/fwd/combine\_latest.hpp>}            \textcolor{comment}{// own forwarding}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <rpp/subscribers/constraints.hpp>}                 \textcolor{comment}{// constraint::subscriber\_of\_type}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <rpp/utils/spinlock.hpp>}                          \textcolor{comment}{// spinlock}}
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{23 }
\DoxyCodeLine{24 IMPLEMENTATION\_FILE(combine\_latest\_tag);}
\DoxyCodeLine{25 }
\DoxyCodeLine{26 \textcolor{keyword}{namespace }rpp::details}
\DoxyCodeLine{27 \{}
\DoxyCodeLine{33 \textcolor{keyword}{template}<\textcolor{keyword}{typename} TCombiner, constraint::decayed\_type... Types>}
\DoxyCodeLine{34 \textcolor{keyword}{struct }\mbox{\hyperlink{structrpp_1_1details_1_1combine__latest__state}{combine\_latest\_state}} : \textcolor{keyword}{public} \mbox{\hyperlink{structrpp_1_1details_1_1merge__state}{merge\_state}}}
\DoxyCodeLine{35 \{}
\DoxyCodeLine{36     \textcolor{keyword}{explicit} \mbox{\hyperlink{structrpp_1_1details_1_1combine__latest__state}{combine\_latest\_state}}(\textcolor{keyword}{const} TCombiner\& combiner, \textcolor{keyword}{const} \mbox{\hyperlink{classrpp_1_1composite__subscription}{composite\_subscription}}\& subscription\_of\_subscriber)}
\DoxyCodeLine{37         : \mbox{\hyperlink{structrpp_1_1details_1_1merge__state}{merge\_state}}(subscription\_of\_subscriber)}
\DoxyCodeLine{38         , combiner(combiner) \{\}}
\DoxyCodeLine{39 }
\DoxyCodeLine{40     \textcolor{comment}{// don't use NO\_UNIQUE\_ADDRESS there due to issue in MSVC base class becomes invalid}}
\DoxyCodeLine{41     \textcolor{comment}{/*NO\_UNIQUE\_ADDRESS*/} TCombiner     combiner;}
\DoxyCodeLine{42     std::mutex                          values\_mutex\{\};}
\DoxyCodeLine{43     std::tuple<std::optional<Types>...> values\{\};}
\DoxyCodeLine{44 \};}
\DoxyCodeLine{45 }
\DoxyCodeLine{46 \textcolor{keyword}{template}<\textcolor{keywordtype}{size\_t} I>}
\DoxyCodeLine{47 \textcolor{keyword}{struct }\mbox{\hyperlink{structrpp_1_1details_1_1combine__latest__on__next}{combine\_latest\_on\_next}}}
\DoxyCodeLine{48 \{}
\DoxyCodeLine{49     \textcolor{keyword}{template}<\textcolor{keyword}{typename} TCombiner, constraint::decayed\_type... Types>}
\DoxyCodeLine{50     \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{auto}\&\&                                                            value,}
\DoxyCodeLine{51                     \textcolor{keyword}{const} \textcolor{keyword}{auto}\&                                                       subscriber,}
\DoxyCodeLine{52                     \textcolor{keyword}{const} std::shared\_ptr<\mbox{\hyperlink{structrpp_1_1details_1_1combine__latest__state}{combine\_latest\_state<TCombiner, Types...>}}>\& state)\textcolor{keyword}{ const}}
\DoxyCodeLine{53 \textcolor{keyword}{    }\{}
\DoxyCodeLine{54         \textcolor{comment}{// mutex need to be locked during changing of values, generating new values and sending of new values due to we can't update value while we are sending old one}}
\DoxyCodeLine{55         std::scoped\_lock lock\{state-\/>values\_mutex\};}
\DoxyCodeLine{56         std::get<I>(state-\/>values) = std::forward<decltype(value)>(value);}
\DoxyCodeLine{57 }
\DoxyCodeLine{58         std::apply([\&](\textcolor{keyword}{const} \textcolor{keyword}{auto}\&...cached\_values)}
\DoxyCodeLine{59                    \{}
\DoxyCodeLine{60                        \textcolor{keywordflow}{if} ((cached\_values.has\_value() \&\& ...))}
\DoxyCodeLine{61                            subscriber.on\_next(state-\/>combiner(cached\_values.value()...));}
\DoxyCodeLine{62                    \},}
\DoxyCodeLine{63                    state-\/>values);}
\DoxyCodeLine{64     \}}
\DoxyCodeLine{65 \};}
\DoxyCodeLine{66 }
\DoxyCodeLine{67 \textcolor{keyword}{using }\mbox{\hyperlink{structrpp_1_1details_1_1early__unsubscribe__on__error}{combine\_latest\_on\_error}}     = \mbox{\hyperlink{structrpp_1_1details_1_1early__unsubscribe__on__error}{merge\_on\_error}};}
\DoxyCodeLine{68 \textcolor{keyword}{using }\mbox{\hyperlink{structrpp_1_1details_1_1merge__on__completed}{combine\_latest\_on\_completed}} = \mbox{\hyperlink{structrpp_1_1details_1_1merge__on__completed}{merge\_on\_completed}};}
\DoxyCodeLine{69 }
\DoxyCodeLine{70 \textcolor{keyword}{template}<\textcolor{keyword}{typename} TCombiner, constraint::decayed\_type... Types>}
\DoxyCodeLine{71 \textcolor{keyword}{struct }\mbox{\hyperlink{structrpp_1_1details_1_1combine__latest__state__with__serialized__spinlock}{combine\_latest\_state\_with\_serialized\_spinlock}} : \mbox{\hyperlink{structrpp_1_1details_1_1combine__latest__state}{combine\_latest\_state}}<TCombiner,Types...>}
\DoxyCodeLine{72 \{}
\DoxyCodeLine{73     \textcolor{keyword}{using }\mbox{\hyperlink{structrpp_1_1details_1_1combine__latest__state}{combine\_latest\_state}}<TCombiner,Types...>::combine\_latest\_state;}
\DoxyCodeLine{74 }
\DoxyCodeLine{75     \textcolor{comment}{// we can use spinlock there because 99.9\% of time only one ever thread would send values from on\_next serialized (due to values\_mutex), but we have small probability to get error from another observable immediately}}
\DoxyCodeLine{76     utils::spinlock spinlock\{\};}
\DoxyCodeLine{77 \};}
\DoxyCodeLine{78 }
\DoxyCodeLine{82 \textcolor{keyword}{template}<constraint::decayed\_type Type, \textcolor{keyword}{typename} TCombiner, \mbox{\hyperlink{conceptrpp_1_1constraint_1_1observable}{constraint::observable}} ...TOtherObservable>}
\DoxyCodeLine{83 \textcolor{keyword}{struct }\mbox{\hyperlink{structrpp_1_1details_1_1combine__latest__impl}{combine\_latest\_impl}}}
\DoxyCodeLine{84 \{}
\DoxyCodeLine{85     RPP\_NO\_UNIQUE\_ADDRESS TCombiner                       m\_combiner;}
\DoxyCodeLine{86     RPP\_NO\_UNIQUE\_ADDRESS std::tuple<TOtherObservable...> m\_other\_observables;}
\DoxyCodeLine{87 }
\DoxyCodeLine{88 \textcolor{keyword}{private}:}
\DoxyCodeLine{89     \textcolor{keyword}{static} \textcolor{keyword}{constexpr} \textcolor{keywordtype}{size\_t} s\_index\_of\_source\_type = 0;}
\DoxyCodeLine{90 }
\DoxyCodeLine{97     \textcolor{keyword}{template}<\textcolor{keywordtype}{size\_t}...I>}
\DoxyCodeLine{98     \textcolor{keywordtype}{void} subscribe\_other\_observables(std::index\_sequence<I...>,}
\DoxyCodeLine{99                                      \textcolor{comment}{// Used in compile time for variadic expansion}}
\DoxyCodeLine{100                                      \textcolor{keyword}{const} \textcolor{keyword}{auto}\& subscriber,}
\DoxyCodeLine{101                                      \textcolor{keyword}{const} std::shared\_ptr<\mbox{\hyperlink{structrpp_1_1details_1_1combine__latest__state}{combine\_latest\_state}}<TCombiner, Type, utils::extract\_observable\_type\_t<TOtherObservable>...>>\& state)\textcolor{keyword}{ const}}
\DoxyCodeLine{102 \textcolor{keyword}{    }\{}
\DoxyCodeLine{103         \textcolor{comment}{// +1 because the first element in tuple is the current observable, and you want to subscribe to the 'other' observables.}}
\DoxyCodeLine{104         \textcolor{comment}{// (Use variadic expansion to iterate the observables)}}
\DoxyCodeLine{105         (subscribe\_observable<I + 1>(std::get<I>(m\_other\_observables), subscriber, state), ...);}
\DoxyCodeLine{106     \}}
\DoxyCodeLine{107 }
\DoxyCodeLine{108     \textcolor{keyword}{template}<\textcolor{keywordtype}{size\_t} I, constra\textcolor{keywordtype}{int}::observable TObservable>}
\DoxyCodeLine{109     \textcolor{keyword}{static} \textcolor{keywordtype}{void} subscribe\_observable(\textcolor{keyword}{const} TObservable\& observable, \textcolor{keyword}{const} \textcolor{keyword}{auto}\& subscriber, \textcolor{keyword}{const} std::shared\_ptr<\mbox{\hyperlink{structrpp_1_1details_1_1combine__latest__state}{combine\_latest\_state}}<TCombiner, Type, utils::extract\_observable\_type\_t<TOtherObservable>...>>\& state)}
\DoxyCodeLine{110     \{}
\DoxyCodeLine{111         \textcolor{keyword}{using }ValueType = utils::extract\_observable\_type\_t<TObservable>;}
\DoxyCodeLine{112         observable.subscribe(create\_inner\_subscriber<ValueType, I>(subscriber, state));}
\DoxyCodeLine{113     \}}
\DoxyCodeLine{114 }
\DoxyCodeLine{115     \textcolor{keyword}{template}<\textcolor{keyword}{typename} ValueType, \textcolor{keywordtype}{size\_t} I>}
\DoxyCodeLine{116     \textcolor{keyword}{static} \textcolor{keyword}{auto} create\_inner\_subscriber(\textcolor{keyword}{auto}\&\&                 subscriber,}
\DoxyCodeLine{117                                         std::shared\_ptr<\mbox{\hyperlink{structrpp_1_1details_1_1combine__latest__state}{combine\_latest\_state}}<TCombiner, Type, utils::extract\_observable\_type\_t<TOtherObservable>...>> state)}
\DoxyCodeLine{118     \{}
\DoxyCodeLine{119         \textcolor{keyword}{auto} subscription = state-\/>children\_subscriptions.make\_child();}
\DoxyCodeLine{120         \textcolor{keywordflow}{return} create\_subscriber\_with\_state<ValueType>(std::move(subscription),}
\DoxyCodeLine{121                                                        \mbox{\hyperlink{structrpp_1_1details_1_1combine__latest__on__next}{combine\_latest\_on\_next<I>}}\{\},}
\DoxyCodeLine{122                                                        \mbox{\hyperlink{structrpp_1_1details_1_1early__unsubscribe__on__error}{combine\_latest\_on\_error}}\{\},}
\DoxyCodeLine{123                                                        \mbox{\hyperlink{structrpp_1_1details_1_1merge__on__completed}{combine\_latest\_on\_completed}}\{\},}
\DoxyCodeLine{124                                                        std::forward<decltype(subscriber)>(subscriber),}
\DoxyCodeLine{125                                                        std::move(state));}
\DoxyCodeLine{126     \}}
\DoxyCodeLine{127 }
\DoxyCodeLine{128 }
\DoxyCodeLine{129 \textcolor{keyword}{public}:}
\DoxyCodeLine{130     \textcolor{keyword}{using }DownstreamType = utils::decayed\_invoke\_result\_t<TCombiner, Type, utils::extract\_observable\_type\_t<TOtherObservable>...>;}
\DoxyCodeLine{131 }
\DoxyCodeLine{132     \textcolor{keyword}{template}<constra\textcolor{keywordtype}{int}::subscriber\_of\_type<DownstreamType> TSub>}
\DoxyCodeLine{133     \textcolor{keyword}{auto} operator()(TSub\&\& in\_subscriber)\textcolor{keyword}{ const}}
\DoxyCodeLine{134 \textcolor{keyword}{    }\{}
\DoxyCodeLine{135         \textcolor{keyword}{auto} state = std::make\_shared<combine\_latest\_state\_with\_serialized\_spinlock<TCombiner, Type, utils::extract\_observable\_type\_t<TOtherObservable>...>>(m\_combiner, in\_subscriber.get\_subscription());}
\DoxyCodeLine{136         \textcolor{comment}{// change subscriber to serialized to avoid manual using of mutex}}
\DoxyCodeLine{137         \textcolor{keyword}{auto} subscriber = make\_serialized\_subscriber(std::forward<TSub>(in\_subscriber), std::shared\_ptr<utils::spinlock>\{state, \&state-\/>spinlock\});}
\DoxyCodeLine{138 }
\DoxyCodeLine{139         state-\/>count\_of\_on\_completed\_needed.store(\textcolor{keyword}{sizeof}...(TOtherObservable) + 1, std::memory\_order::relaxed);}
\DoxyCodeLine{140 }
\DoxyCodeLine{141         \textcolor{comment}{// Subscribe to other observables and redirect on\_next event to state}}
\DoxyCodeLine{142         subscribe\_other\_observables(std::index\_sequence\_for<TOtherObservable...>\{\}, subscriber, state);}
\DoxyCodeLine{143 }
\DoxyCodeLine{144         \textcolor{comment}{// Redirect values from this observable to the state for value composition}}
\DoxyCodeLine{145         \textcolor{keywordflow}{return} create\_inner\_subscriber<Type, s\_index\_of\_source\_type>(std::move(subscriber), std::move(state));}
\DoxyCodeLine{146     \}}
\DoxyCodeLine{147 \};}
\DoxyCodeLine{148 \} \textcolor{comment}{// namespace rpp::details}}

\end{DoxyCode}
