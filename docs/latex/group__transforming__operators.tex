\hypertarget{group__transforming__operators}{}\doxysection{Transforming Operators}
\label{group__transforming__operators}\index{Transforming Operators@{Transforming Operators}}


Transforming operators are operators that transform items provided by observable.  


\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename ... Args$>$ \newline
requires is\+\_\+header\+\_\+included$<$buffer\+\_\+tag, Args...$>$}\\auto \mbox{\hyperlink{group__transforming__operators_gaaaadd88de768811a7397897432b00f17}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, buffer\+\_\+tag $>$\+::buffer}} (size\+\_\+t count) const \&
\begin{DoxyCompactList}\small\item\em Periodically gather emissions emitted by an original Observable into bundles and emit these bundles rather than emitting the items one at a time. \end{DoxyCompactList}\item 
{\footnotesize template$<$flat\+\_\+map\+\_\+callable$<$ Type $>$ Callable$>$ \newline
requires is\+\_\+header\+\_\+included$<$flat\+\_\+map\+\_\+tag, Callable$>$}\\auto \mbox{\hyperlink{group__transforming__operators_ga855aea700aa9aa9fa07e8aab7e193a1a}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, flat\+\_\+map\+\_\+tag $>$\+::flat\+\_\+map}} (Callable \&\&callable) const \&
\begin{DoxyCompactList}\small\item\em Transform emissions to observables via provided function and then merge emissions from such an observables. \end{DoxyCompactList}\item 
{\footnotesize template$<$std\+::invocable$<$ Type $>$ Key\+Selector, std\+::invocable$<$ Type $>$ Value\+Selector = std\+::identity, typename TKey  = rpp\+::utils\+::decayed\+\_\+invoke\+\_\+result\+\_\+t$<$\+Key\+Selector, Type$>$, std\+::strict\+\_\+weak\+\_\+order$<$ TKey, TKey $>$ Key\+Comparator = std\+::less$<$\+TKey$>$$>$ \newline
requires is\+\_\+header\+\_\+included$<$group\+\_\+by\+\_\+tag, Key\+Selector, Value\+Selector, TKey, Key\+Comparator$>$}\\auto \mbox{\hyperlink{group__transforming__operators_ga61277d8115a87b4c10f7856a9a7f8d35}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, group\+\_\+by\+\_\+tag $>$\+::group\+\_\+by}} (Key\+Selector \&\&key\+\_\+selector, Value\+Selector \&\&value\+\_\+selector=\{\}, Key\+Comparator \&\&comparator=\{\}) const \&
\begin{DoxyCompactList}\small\item\em Divide original observable into multiple observables where each new observable emits some group of values from original observable. \end{DoxyCompactList}\item 
{\footnotesize template$<$std\+::invocable$<$ Type $>$ Callable$>$ \newline
requires is\+\_\+header\+\_\+included$<$map\+\_\+tag, Callable$>$}\\auto \mbox{\hyperlink{group__transforming__operators_gae5dd31e4559517de5cf1145ff2005a86}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, map\+\_\+tag $>$\+::map}} (Callable \&\&callable) const \&
\begin{DoxyCompactList}\small\item\em Transform the items emitted by an Observable via applying a function to each item and emitting result. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Result , scan\+\_\+accumulator$<$ Result, Type $>$ Accumulator\+Fn$>$ \newline
requires is\+\_\+header\+\_\+included$<$scan\+\_\+tag, Result, Accumulator\+Fn$>$}\\auto \mbox{\hyperlink{group__transforming__operators_ga32b19b1b37ecd7a14d08c5936e2023e1}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, scan\+\_\+tag $>$\+::scan}} (Result \&\&initial\+\_\+value, Accumulator\+Fn \&\&accumulator) const \&
\begin{DoxyCompactList}\small\item\em Apply accumulator function for each emission from observable and result of accumulator from previous step and emit (and cache) resulting value. \end{DoxyCompactList}\item 
{\footnotesize template$<$switch\+\_\+map\+\_\+callable$<$ Type $>$ Callable$>$ \newline
requires is\+\_\+header\+\_\+included$<$switch\+\_\+map\+\_\+tag, Callable$>$}\\auto \mbox{\hyperlink{group__transforming__operators_gae76b0e38003420a5ced3c1159bbbadde}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, switch\+\_\+map\+\_\+tag $>$\+::switch\+\_\+map}} (Callable \&\&callable) const \&
\begin{DoxyCompactList}\small\item\em convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-\/recently-\/emitted of those Observables \end{DoxyCompactList}\item 
{\footnotesize template$<$typename ... Args$>$ \newline
requires is\+\_\+header\+\_\+included$<$window\+\_\+tag, Args...$>$}\\auto \mbox{\hyperlink{group__transforming__operators_gaae1e46e322134df2b377da37a2b2f8d4}{rpp\+::details\+::member\+\_\+overload$<$ Type, Specific\+Observable, window\+\_\+tag $>$\+::window}} (size\+\_\+t window\+\_\+size) const \&
\begin{DoxyCompactList}\small\item\em Subdivide original observable into sub-\/observables (windowed observables) and emit sub-\/observables of items instead of original items. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Transforming operators are operators that transform items provided by observable. 

\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators.html\#transforming}{\texttt{ https\+://reactivex.\+io/documentation/operators.\+html\#transforming}} 
\end{DoxySeeAlso}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{group__transforming__operators_gaaaadd88de768811a7397897432b00f17}\label{group__transforming__operators_gaaaadd88de768811a7397897432b00f17}} 
\index{Transforming Operators@{Transforming Operators}!buffer@{buffer}}
\index{buffer@{buffer}!Transforming Operators@{Transforming Operators}}
\doxysubsubsection{\texorpdfstring{buffer()}{buffer()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$typename ... Args$>$ \newline
requires is\+\_\+header\+\_\+included$<$buffer\+\_\+tag, Args...$>$\\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, buffer\+\_\+tag $>$\+::buffer (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count }\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [inline]}}



Periodically gather emissions emitted by an original Observable into bundles and emit these bundles rather than emitting the items one at a time. 



The resulting bundle is {\ttfamily std\+::vector\texorpdfstring{$<$}{<}Type\texorpdfstring{$>$}{>}} of requested size. Actually it is similar to {\ttfamily window()} operator, but it emits vectors instead of observables.


\begin{DoxyParams}{Parameters}
{\em count} & number of items being bundled. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
new \doxylink{classrpp_1_1specific__observable}{specific\+\_\+observable} with the buffer operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include \texorpdfstring{$<$}{<}\doxylink{buffer_8hpp_source}{rpp/operators/buffer.\+hpp}\texorpdfstring{$>$}{>}
\end{DoxyWarning}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ The\ stream\ that\ uses\ rvalue\ overloads\ for\ operators}}
\DoxyCodeLine{\ \ \ \ rpp::source::just(1,\ 2,\ 3,\ 4,\ 5)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ .buffer(2)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ .subscribe(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ [](\textcolor{keyword}{const}\ std::vector<int>\&\ v)\ \{\ std::cout\ <<\ v\ <<\ \textcolor{stringliteral}{"{}-\/"{}};\ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ [](\textcolor{keyword}{const}\ std::exception\_ptr\&)\ \{\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ []()\ \{\ std::cout\ <<\ \textcolor{stringliteral}{"{}|"{}}\ <<\ std::endl;\ \});}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Source:\ -\/1-\/2-\/3-\/4-\/5-\/-\/|}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Output:\ \{1,2\}-\/\{3,4\}-\/\{5\}-\/|}}

\end{DoxyCodeInclude}

\end{DoxyParagraph}
\begin{DoxyParagraph}{Implementation details\+:}

\begin{DoxyItemize}
\item {\bfseries{On subscribe}}
\begin{DoxyItemize}
\item Allocates one {\ttfamily shared\+\_\+ptr} to store {\ttfamily std\+::vector\texorpdfstring{$<$}{<}Type\texorpdfstring{$>$}{>}} of requested size.
\end{DoxyItemize}
\item {\bfseries{On\+Next}}
\begin{DoxyItemize}
\item Accumulates emissions inside current bundle and emits this bundle when requested cound reached and starts new bundle.
\end{DoxyItemize}
\item {\bfseries{On\+Error}}
\begin{DoxyItemize}
\item Just forwards original on\+\_\+error
\end{DoxyItemize}
\item {\bfseries{On\+Completed}}
\begin{DoxyItemize}
\item Emits current active bundle (if any) and just forwards on\+\_\+completed
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyParagraph}
\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/buffer.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/buffer.\+html}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__transforming__operators_ga855aea700aa9aa9fa07e8aab7e193a1a}\label{group__transforming__operators_ga855aea700aa9aa9fa07e8aab7e193a1a}} 
\index{Transforming Operators@{Transforming Operators}!flat\_map@{flat\_map}}
\index{flat\_map@{flat\_map}!Transforming Operators@{Transforming Operators}}
\doxysubsubsection{\texorpdfstring{flat\_map()}{flat\_map()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$flat\+\_\+map\+\_\+callable$<$ Type $>$ Callable$>$ \newline
requires is\+\_\+header\+\_\+included$<$flat\+\_\+map\+\_\+tag, Callable$>$\\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, flat\+\_\+map\+\_\+tag $>$\+::flat\+\_\+map (\begin{DoxyParamCaption}\item[{Callable \&\&}]{callable }\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [inline]}}



Transform emissions to observables via provided function and then merge emissions from such an observables. 

\begin{DoxyWarning}{Warning}
According to observable contract (\href{https://reactivex.io/documentation/contract.html}{\texttt{ https\+://reactivex.\+io/documentation/contract.\+html}}) emissions from any observable should be serialized, so, resulting observable uses mutex to satisfy this requirement
\end{DoxyWarning}


Actually it makes {\ttfamily map(callable)} and then {\ttfamily merge}.


\begin{DoxyParams}{Parameters}
{\em callable} & Function to transform item to observable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
new \doxylink{classrpp_1_1specific__observable}{specific\+\_\+observable} with the flat\+\_\+map operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include \texorpdfstring{$<$}{<}\doxylink{flat__map_8hpp_source}{rpp/operators/flat\+\_\+map.\+hpp}\texorpdfstring{$>$}{>}
\end{DoxyWarning}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ rpp::source::just(1,\ 2,\ 3)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ .flat\_map([](\textcolor{keywordtype}{int}\ val)\ \{\ \textcolor{keywordflow}{return}\ rpp::source::from\_iterable(std::vector(val,\ val));\ \})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ .subscribe([](\textcolor{keywordtype}{int}\ v)\ \{\ std::cout\ <<\ v\ <<\ \textcolor{stringliteral}{"{}\ "{}};\ \});}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Output:\ 1\ 2\ 2\ 3\ 3\ 3}}

\end{DoxyCodeInclude}

\end{DoxyParagraph}
\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/flatmap.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/flatmap.\+html}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__transforming__operators_ga61277d8115a87b4c10f7856a9a7f8d35}\label{group__transforming__operators_ga61277d8115a87b4c10f7856a9a7f8d35}} 
\index{Transforming Operators@{Transforming Operators}!group\_by@{group\_by}}
\index{group\_by@{group\_by}!Transforming Operators@{Transforming Operators}}
\doxysubsubsection{\texorpdfstring{group\_by()}{group\_by()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$std\+::invocable$<$ Type $>$ Key\+Selector, std\+::invocable$<$ Type $>$ Value\+Selector = std\+::identity, typename TKey  = rpp\+::utils\+::decayed\+\_\+invoke\+\_\+result\+\_\+t$<$\+Key\+Selector, Type$>$, std\+::strict\+\_\+weak\+\_\+order$<$ TKey, TKey $>$ Key\+Comparator = std\+::less$<$\+TKey$>$$>$ \newline
requires is\+\_\+header\+\_\+included$<$group\+\_\+by\+\_\+tag, Key\+Selector, Value\+Selector, TKey, Key\+Comparator$>$\\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, group\+\_\+by\+\_\+tag $>$\+::group\+\_\+by (\begin{DoxyParamCaption}\item[{Key\+Selector \&\&}]{key\+\_\+selector,  }\item[{Value\+Selector \&\&}]{value\+\_\+selector = {\ttfamily \{\}},  }\item[{Key\+Comparator \&\&}]{comparator = {\ttfamily \{\}} }\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [inline]}}



Divide original observable into multiple observables where each new observable emits some group of values from original observable. 



Actually this operator applies {\ttfamily key\+\_\+selector} to emission to obtain key, place \doxylink{classrpp_1_1grouped__observable}{rpp\+::grouped\+\_\+observable} to map with corresponding map and then send observable with this key (if not yet). Original values emitted via this grouped\+\_\+observables


\begin{DoxyParams}{Parameters}
{\em key\+\_\+selector} & Function which determines key for provided item \\
\hline
{\em value\+\_\+selector} & Function which determines value to be emitted to grouped observable \\
\hline
{\em comparator} & Function to provide strict\+\_\+weak\+\_\+order between key types\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
new \doxylink{classrpp_1_1specific__observable}{specific\+\_\+observable} with the group\+\_\+by operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include \texorpdfstring{$<$}{<}\doxylink{group__by_8hpp_source}{rpp/operators/group\+\_\+by.\+hpp}\texorpdfstring{$>$}{>}
\end{DoxyWarning}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ rpp::source::just(1,\ 2,\ 3,\ 4,\ 5,\ 6,\ 7,\ 8)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ .group\_by([](\textcolor{keywordtype}{int}\ \ \ v)\ \{\ \textcolor{keywordflow}{return}\ v\ \%\ 2\ ==\ 0;\ \})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ .subscribe([](\textcolor{keyword}{auto}\ grouped\_observable)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{auto}\ key\ =\ grouped\_observable.get\_key();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}new\ grouped\ observable\ "{}}\ <<\ key\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ grouped\_observable.subscribe([key](\textcolor{keywordtype}{int}\ val)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}key\ ["{}}\ <<\ key\ <<\ \textcolor{stringliteral}{"{}]\ Val:\ "{}}\ <<\ val\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \});}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Output:\ new\ grouped\ observable\ 0}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ key\ [0]\ Val:\ 1}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ new\ grouped\ observable\ 1}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ key\ [1]\ Val:\ 2}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ key\ [0]\ Val:\ 3}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ key\ [1]\ Val:\ 4}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ key\ [0]\ Val:\ 5}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ key\ [1]\ Val:\ 6}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ key\ [0]\ Val:\ 7}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ key\ [1]\ Val:\ 8}}

\end{DoxyCodeInclude}
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{struct\ }Person}
\DoxyCodeLine{\ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::string\ name;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ age;}
\DoxyCodeLine{\ \ \ \ \};}
\DoxyCodeLine{\ \ \ \ rpp::source::just(Person\{\textcolor{stringliteral}{"{}Kate"{}},\ 18\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Person\{\textcolor{stringliteral}{"{}Alex"{}},\ 25\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Person\{\textcolor{stringliteral}{"{}Nick"{}},\ 18\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Person\{\textcolor{stringliteral}{"{}Jack"{}},\ 25\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Person\{\textcolor{stringliteral}{"{}Tom"{}},\ 30\},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Person\{\textcolor{stringliteral}{"{}Vanda"{}},\ 18\})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ .\mbox{\hyperlink{group__transforming__operators_ga61277d8115a87b4c10f7856a9a7f8d35}{group\_by}}([](\textcolor{keyword}{const}\ Person\&\ v)\ \{\ \textcolor{keywordflow}{return}\ v.age;\ \},\ [](\textcolor{keyword}{const}\ Person\&\ v)\ \{\ \textcolor{keywordflow}{return}\ v.name;\ \})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ .subscribe([](\textcolor{keyword}{auto}\ grouped\_observable)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ grouped\_observable.subscribe([age\ =\ grouped\_observable.get\_key()](\textcolor{keyword}{const}\ std::string\&\ name)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}Age\ ["{}}\ <<\ age\ <<\ \textcolor{stringliteral}{"{}]\ Name:\ "{}}\ <<\ name\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \});}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Output:\ Age\ [18]\ Name:\ Kate}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ Age\ [25]\ Name:\ Alex}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ Age\ [18]\ Name:\ Nick}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ Age\ [25]\ Name:\ Jack}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ Age\ [30]\ Name:\ Tom}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ Age\ [18]\ Name:\ Vanda}}

\end{DoxyCodeInclude}

\end{DoxyParagraph}
\begin{DoxyParagraph}{Implementation details\+:}

\begin{DoxyItemize}
\item {\bfseries{On subscribe}}
\begin{DoxyItemize}
\item Allocates one {\ttfamily shared\+\_\+ptr} to keep map$<$key, grouped\+\_\+observable$>$
\end{DoxyItemize}
\item {\bfseries{On\+Next}}
\begin{DoxyItemize}
\item Applies key\+\_\+selector to obtained emission
\item For calculated key create new entry in map (if not yet)
\item Emit value via \doxylink{classrpp_1_1grouped__observable}{grouped\+\_\+observable} from map for corresponding key
\end{DoxyItemize}
\item {\bfseries{On\+Error}}
\begin{DoxyItemize}
\item Just forwards original on\+\_\+error to both subscribers of observable of grouped observables and grouped observables
\end{DoxyItemize}
\item {\bfseries{On\+Completed}}
\begin{DoxyItemize}
\item Just forwards original on\+\_\+completed to both subscribers of observable of grouped observables and grouped observables
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyParagraph}
\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/groupby.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/groupby.\+html}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__transforming__operators_gae5dd31e4559517de5cf1145ff2005a86}\label{group__transforming__operators_gae5dd31e4559517de5cf1145ff2005a86}} 
\index{Transforming Operators@{Transforming Operators}!map@{map}}
\index{map@{map}!Transforming Operators@{Transforming Operators}}
\doxysubsubsection{\texorpdfstring{map()}{map()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$std\+::invocable$<$ Type $>$ Callable$>$ \newline
requires is\+\_\+header\+\_\+included$<$map\+\_\+tag, Callable$>$\\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, map\+\_\+tag $>$\+::map (\begin{DoxyParamCaption}\item[{Callable \&\&}]{callable }\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [inline]}}



Transform the items emitted by an Observable via applying a function to each item and emitting result. 

\begin{DoxyNote}{Note}
The Map operator can keep same type of value or change it to some another type.
\end{DoxyNote}


Actually this operator just applies callable to each obtained emission and emit resulting value


\begin{DoxyParams}{Parameters}
{\em callable} & is callable used to provide this transformation. Should accept Type of original observable and return type for new observable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
new \doxylink{classrpp_1_1specific__observable}{specific\+\_\+observable} with the Map operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include \texorpdfstring{$<$}{<}\doxylink{map_8hpp_source}{rpp/operators/map.\+hpp}\texorpdfstring{$>$}{>}
\end{DoxyWarning}
\begin{DoxyParagraph}{Example with same type\+:}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ rpp::source::just(42)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ .map([](\textcolor{keywordtype}{int}\ value)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ value\ +\ 10;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ .subscribe([](\textcolor{keywordtype}{int}\ v)\ \{\ std::cout\ <<\ v\ <<\ std::endl;\ \});}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Output:\ 52}}

\end{DoxyCodeInclude}

\end{DoxyParagraph}
\begin{DoxyParagraph}{Example with changed type\+:}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ rpp::source::just(42)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ .map([](\textcolor{keywordtype}{int}\ value)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::to\_string(value)\ +\ \textcolor{stringliteral}{"{}\ VAL"{}};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ .subscribe([](std::string\ v)\ \{\ std::cout\ <<\ v\ <<\ std::endl;\ \});}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Output:\ 42\ VAL}}

\end{DoxyCodeInclude}

\end{DoxyParagraph}
\begin{DoxyParagraph}{Implementation details\+:}

\begin{DoxyItemize}
\item {\bfseries{On subscribe}}
\begin{DoxyItemize}
\item None
\end{DoxyItemize}
\item {\bfseries{On\+Next}}
\begin{DoxyItemize}
\item Just forwards result of applying callable to emissions
\end{DoxyItemize}
\item {\bfseries{On\+Error}}
\begin{DoxyItemize}
\item Just forwards original on\+\_\+error
\end{DoxyItemize}
\item {\bfseries{On\+Completed}}
\begin{DoxyItemize}
\item Just forwards original on\+\_\+completed
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyParagraph}
\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/map.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/map.\+html}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__transforming__operators_ga32b19b1b37ecd7a14d08c5936e2023e1}\label{group__transforming__operators_ga32b19b1b37ecd7a14d08c5936e2023e1}} 
\index{Transforming Operators@{Transforming Operators}!scan@{scan}}
\index{scan@{scan}!Transforming Operators@{Transforming Operators}}
\doxysubsubsection{\texorpdfstring{scan()}{scan()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$typename Result , scan\+\_\+accumulator$<$ Result, Type $>$ Accumulator\+Fn$>$ \newline
requires is\+\_\+header\+\_\+included$<$scan\+\_\+tag, Result, Accumulator\+Fn$>$\\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, scan\+\_\+tag $>$\+::scan (\begin{DoxyParamCaption}\item[{Result \&\&}]{initial\+\_\+value,  }\item[{Accumulator\+Fn \&\&}]{accumulator }\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [inline]}}



Apply accumulator function for each emission from observable and result of accumulator from previous step and emit (and cache) resulting value. 



Acttually this operator applies provided accumulator function to seed and new emission, emits resulting value and updates seed value for next emission


\begin{DoxyParams}{Parameters}
{\em initial\+\_\+value} & initial value for seed which will be applied for first value from observable (instead of emitting this as first value). Then it will be replaced with result and etc. \\
\hline
{\em accumulator} & function which accepts seed value and new value from observable and return new value of seed. Can accept seed by move-\/reference.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
new \doxylink{classrpp_1_1specific__observable}{specific\+\_\+observable} with the scan operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include \texorpdfstring{$<$}{<}\doxylink{scan_8hpp_source}{rpp/operators/scan.\+hpp}\texorpdfstring{$>$}{>}
\end{DoxyWarning}
\begin{DoxyParagraph}{Example}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ rpp::source::just(1,2,3)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ .scan(0,\ std::plus<int>\{\})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ .subscribe([](\textcolor{keywordtype}{int}\ v)\ \{\ std::cout\ <<\ v\ <<\ std::endl;\ \});}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Output:\ 1\ 3\ 6}}

\end{DoxyCodeInclude}
 
\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ rpp::source::just(1,2,3)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ .scan(std::vector<int>\{\},\ [](std::vector<int>\&\&\ seed,\ \textcolor{keywordtype}{int}\ new\_value)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ seed.push\_back(new\_value);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ std::move(seed);}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ .subscribe([](\textcolor{keyword}{const}\ std::vector<int>\&\ v)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}vector:\ "{}};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int}\ val\ :\ v)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ val\ <<\ \textcolor{stringliteral}{"{}\ "{}};}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ std::endl;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \});}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Output:\ vector:\ 1}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ vector:\ 1\ 2}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ vector:\ 1\ 2\ 3}}

\end{DoxyCodeInclude}

\end{DoxyParagraph}
\begin{DoxyParagraph}{Implementation details\+:}

\begin{DoxyItemize}
\item {\bfseries{On subscribe}}
\begin{DoxyItemize}
\item Allocates one {\ttfamily shared\+\_\+ptr} to store seed
\end{DoxyItemize}
\item {\bfseries{On\+Next}}
\begin{DoxyItemize}
\item Applies accumulator to each emission
\item Updates seed value
\item Emits new seed value
\end{DoxyItemize}
\item {\bfseries{On\+Error}}
\begin{DoxyItemize}
\item Just forwards original on\+\_\+error
\end{DoxyItemize}
\item {\bfseries{On\+Completed}}
\begin{DoxyItemize}
\item Just forwards original on\+\_\+completed
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyParagraph}
\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/scan.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/scan.\+html}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__transforming__operators_gae76b0e38003420a5ced3c1159bbbadde}\label{group__transforming__operators_gae76b0e38003420a5ced3c1159bbbadde}} 
\index{Transforming Operators@{Transforming Operators}!switch\_map@{switch\_map}}
\index{switch\_map@{switch\_map}!Transforming Operators@{Transforming Operators}}
\doxysubsubsection{\texorpdfstring{switch\_map()}{switch\_map()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$switch\+\_\+map\+\_\+callable$<$ Type $>$ Callable$>$ \newline
requires is\+\_\+header\+\_\+included$<$switch\+\_\+map\+\_\+tag, Callable$>$\\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, switch\+\_\+map\+\_\+tag $>$\+::switch\+\_\+map (\begin{DoxyParamCaption}\item[{Callable \&\&}]{callable }\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [inline]}}



convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-\/recently-\/emitted of those Observables 



Actually it makes {\ttfamily map} and then {\ttfamily switch\+\_\+on\+\_\+next}.


\begin{DoxyParams}{Parameters}
{\em callable} & Function to transform item to observable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
new \doxylink{classrpp_1_1specific__observable}{specific\+\_\+observable} with the switch\+\_\+map operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include \texorpdfstring{$<$}{<}\doxylink{switch__map_8hpp_source}{rpp/operators/switch\+\_\+map.\+hpp}\texorpdfstring{$>$}{>}
\end{DoxyWarning}
\begin{DoxyParagraph}{Example\+:}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ rpp::source::just(1,\ 2,\ 3)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ .switch\_map([](\textcolor{keywordtype}{int}\ val)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (val\ ==\ 1)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ rpp::source::never<int>()}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .lift([\&](\mbox{\hyperlink{classrpp_1_1dynamic__subscriber}{rpp::dynamic\_subscriber<int>}}\ sub)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ sub.get\_subscription().add([\&]()\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::cout\ <<\ \textcolor{stringliteral}{"{}x-\/"{}};\ \textcolor{comment}{//\ x\ is\ notation\ for\ unsubscribed}}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \});}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ sub;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .as\_dynamic();}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ rpp::source::from\_iterable(std::vector\{val,\ val\})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ .as\_dynamic();}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \})}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ .subscribe([](\textcolor{keywordtype}{int}\ v)\ \{\ std::cout\ <<\ v\ <<\ \textcolor{stringliteral}{"{}-\/"{}};\ \});}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Output:\ x-\/2-\/2-\/3-\/3-\/}}

\end{DoxyCodeInclude}

\end{DoxyParagraph}
\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/switchmap.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/switchmap.\+html}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{group__transforming__operators_gaae1e46e322134df2b377da37a2b2f8d4}\label{group__transforming__operators_gaae1e46e322134df2b377da37a2b2f8d4}} 
\index{Transforming Operators@{Transforming Operators}!window@{window}}
\index{window@{window}!Transforming Operators@{Transforming Operators}}
\doxysubsubsection{\texorpdfstring{window()}{window()}}
{\footnotesize\ttfamily template$<$constraint\+::decayed\+\_\+type Type, typename Specific\+Observable $>$ \\
template$<$typename ... Args$>$ \newline
requires is\+\_\+header\+\_\+included$<$window\+\_\+tag, Args...$>$\\
auto \mbox{\hyperlink{structrpp_1_1details_1_1member__overload}{rpp\+::details\+::member\+\_\+overload}}$<$ Type, Specific\+Observable, window\+\_\+tag $>$\+::window (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{window\+\_\+size }\end{DoxyParamCaption}) const \&\hspace{0.3cm}{\ttfamily [inline]}}



Subdivide original observable into sub-\/observables (windowed observables) and emit sub-\/observables of items instead of original items. 



Actually it is similar to {\ttfamily buffer} but it emits observable instead of container.


\begin{DoxyParams}{Parameters}
{\em window\+\_\+size} & amount of items which every observable would have\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
new \doxylink{classrpp_1_1specific__observable}{specific\+\_\+observable} with the window operator as most recent operator. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
\#include \texorpdfstring{$<$}{<}\doxylink{window_8hpp_source}{rpp/operators/window.\+hpp}\texorpdfstring{$>$}{>}
\end{DoxyWarning}
\begin{DoxyParagraph}{Example}

\begin{DoxyCodeInclude}{0}
\DoxyCodeLine{\ \ \ \ rpp::source::just(1,2,3,4,5)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ .window(3)}
\DoxyCodeLine{\ \ \ \ \ \ \ \ .subscribe([](\textcolor{keyword}{const}\ rpp::windowed\_observable<int>\&\ v)\ \{\ std::cout\ <<\ \textcolor{stringliteral}{"{}\(\backslash\)nNew\ observable\ "{}}\ <<\ std::endl;\ v.subscribe([](\textcolor{keywordtype}{int}\ v)\ \{std::cout\ <<\ v\ <<\ \textcolor{stringliteral}{"{}\ "{}};\ \});\ \});}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Output:\ New\ observable}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ 1\ 2\ 3}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ New\ observable}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ \ \ \ \ \ \ \ \ 4\ 5}}

\end{DoxyCodeInclude}

\end{DoxyParagraph}
\begin{DoxyParagraph}{Implementation details\+:}

\begin{DoxyItemize}
\item {\bfseries{On subscribe}}
\begin{DoxyItemize}
\item Allocates one {\ttfamily shared\+\_\+ptr} to keep internal state
\end{DoxyItemize}
\item {\bfseries{On\+Next}}
\begin{DoxyItemize}
\item Emits new window-\/observable if previous observable emitted requested amound of emisions
\item Emits emission via active window-\/observable
\item Completes window-\/observable if requested amound of emisions reached
\end{DoxyItemize}
\item {\bfseries{On\+Error}}
\begin{DoxyItemize}
\item Just forwards original on\+\_\+error
\end{DoxyItemize}
\item {\bfseries{On\+Completed}}
\begin{DoxyItemize}
\item Just forwards original on\+\_\+completed
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyParagraph}
\begin{DoxySeeAlso}{See also}
\href{https://reactivex.io/documentation/operators/window.html}{\texttt{ https\+://reactivex.\+io/documentation/operators/window.\+html}} 
\end{DoxySeeAlso}
