\hypertarget{delay_8hpp_source}{}\doxysection{delay.\+hpp}
\label{delay_8hpp_source}\index{src/rpp/rpp/operators/delay.hpp@{src/rpp/rpp/operators/delay.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{//                  ReactivePlusPlus library}}
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{//          Copyright Aleksey Loginov 2022 -\/ present.}}
\DoxyCodeLine{4 \textcolor{comment}{//                    TC Wang 2022 -\/ present.}}
\DoxyCodeLine{5 \textcolor{comment}{// Distributed under the Boost Software License, Version 1.0.}}
\DoxyCodeLine{6 \textcolor{comment}{//    (See accompanying file LICENSE\_1\_0.txt or copy at}}
\DoxyCodeLine{7 \textcolor{comment}{//          https://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{8 \textcolor{comment}{//}}
\DoxyCodeLine{9 \textcolor{comment}{// Project home: https://github.com/victimsnino/ReactivePlusPlus}}
\DoxyCodeLine{10 \textcolor{comment}{//}}
\DoxyCodeLine{11 }
\DoxyCodeLine{12 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <rpp/defs.hpp>}                                    \textcolor{comment}{// RPP\_NO\_UNIQUE\_ADDRESS}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <rpp/operators/lift.hpp>}                          \textcolor{comment}{// required due to operator uses lift}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <rpp/operators/details/subscriber\_with\_state.hpp>} \textcolor{comment}{// create\_subscriber\_with\_state}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <rpp/operators/fwd/delay.hpp>}                     \textcolor{comment}{// own forwarding}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <rpp/subscribers/constraints.hpp>}                 \textcolor{comment}{// constraint::subscriber\_of\_type}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <rpp/utils/overloaded.hpp>}}
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include <variant>}}
\DoxyCodeLine{22 }
\DoxyCodeLine{23 IMPLEMENTATION\_FILE(delay\_tag);}
\DoxyCodeLine{24 }
\DoxyCodeLine{25 \textcolor{keyword}{namespace }rpp::details}
\DoxyCodeLine{26 \{}
\DoxyCodeLine{27 \textcolor{keyword}{struct }\mbox{\hyperlink{structrpp_1_1details_1_1completion}{completion}} \{\};}
\DoxyCodeLine{28 }
\DoxyCodeLine{29 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Subscriber, \textcolor{keyword}{typename} Worker>}
\DoxyCodeLine{30 \textcolor{keyword}{class }\mbox{\hyperlink{classrpp_1_1details_1_1queue__based__worker}{queue\_based\_worker}} final : \textcolor{keyword}{public} std::enable\_shared\_from\_this<queue\_based\_worker<T, Subscriber, Worker>>}
\DoxyCodeLine{31 \{}
\DoxyCodeLine{32 \textcolor{keyword}{public}:}
\DoxyCodeLine{33     \mbox{\hyperlink{classrpp_1_1details_1_1queue__based__worker}{queue\_based\_worker}}(schedulers::duration delay, Worker\&\& worker, \textcolor{keyword}{const} Subscriber\& subscriber)}
\DoxyCodeLine{34         : m\_delay\{delay\}}
\DoxyCodeLine{35         , m\_worker\{std::move(worker)\}}
\DoxyCodeLine{36         , m\_subscriber\{subscriber\} \{\}}
\DoxyCodeLine{37 }
\DoxyCodeLine{38     \mbox{\hyperlink{classrpp_1_1details_1_1queue__based__worker}{queue\_based\_worker}}(schedulers::duration delay, Worker\&\& worker, Subscriber\&\& subscriber)}
\DoxyCodeLine{39         : m\_delay\{delay\}}
\DoxyCodeLine{40         , m\_worker\{std::move(worker)\}}
\DoxyCodeLine{41         , m\_subscriber\{std::move(subscriber)\} \{\}}
\DoxyCodeLine{42 }
\DoxyCodeLine{43     \textcolor{keyword}{struct }\mbox{\hyperlink{structrpp_1_1details_1_1queue__based__worker_1_1on__next}{on\_next}}}
\DoxyCodeLine{44     \{}
\DoxyCodeLine{45         \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{auto}\&\& value, \textcolor{keyword}{const} std::shared\_ptr<\mbox{\hyperlink{classrpp_1_1details_1_1queue__based__worker}{queue\_based\_worker<T, Subscriber, Worker>}}>\& state)\textcolor{keyword}{ const}}
\DoxyCodeLine{46 \textcolor{keyword}{        }\{}
\DoxyCodeLine{47             state-\/>emplace(std::forward<\textcolor{keyword}{decltype}(value)>(value));}
\DoxyCodeLine{48         \}}
\DoxyCodeLine{49     \};}
\DoxyCodeLine{50 }
\DoxyCodeLine{51     \textcolor{keyword}{struct }\mbox{\hyperlink{structrpp_1_1details_1_1queue__based__worker_1_1on__error}{on\_error}}}
\DoxyCodeLine{52     \{}
\DoxyCodeLine{53         \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} std::exception\_ptr\& err, \textcolor{keyword}{const} std::shared\_ptr<\mbox{\hyperlink{classrpp_1_1details_1_1queue__based__worker}{queue\_based\_worker<T, Subscriber, Worker>}}>\& state)\textcolor{keyword}{ const}}
\DoxyCodeLine{54 \textcolor{keyword}{        }\{}
\DoxyCodeLine{55             state-\/>emplace(err);}
\DoxyCodeLine{56         \}}
\DoxyCodeLine{57     \};}
\DoxyCodeLine{58 }
\DoxyCodeLine{59     \textcolor{keyword}{struct }\mbox{\hyperlink{structrpp_1_1details_1_1queue__based__worker_1_1on__completed}{on\_completed}}}
\DoxyCodeLine{60     \{}
\DoxyCodeLine{61         \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} std::shared\_ptr<\mbox{\hyperlink{classrpp_1_1details_1_1queue__based__worker}{queue\_based\_worker<T, Subscriber, Worker>}}>\& state)\textcolor{keyword}{ const}}
\DoxyCodeLine{62 \textcolor{keyword}{        }\{}
\DoxyCodeLine{63             state-\/>emplace(\mbox{\hyperlink{structrpp_1_1details_1_1completion}{completion}}\{\});}
\DoxyCodeLine{64         \}}
\DoxyCodeLine{65     \};}
\DoxyCodeLine{66 }
\DoxyCodeLine{67 \textcolor{keyword}{private}:}
\DoxyCodeLine{68     \textcolor{keyword}{template}<\textcolor{keyword}{typename} TT>}
\DoxyCodeLine{69     \textcolor{keywordtype}{void} emplace(TT\&\& item)}
\DoxyCodeLine{70     \{}
\DoxyCodeLine{71         \textcolor{keywordflow}{if} (\textcolor{keyword}{const} \textcolor{keyword}{auto} timepoint = emplace\_safe(std::forward<TT>(item)))}
\DoxyCodeLine{72         \{}
\DoxyCodeLine{73             m\_worker.schedule(timepoint.value(),}
\DoxyCodeLine{74                               [state = this-\/>shared\_from\_this()]()-\/> schedulers::optional\_duration}
\DoxyCodeLine{75                               \{}
\DoxyCodeLine{76                                   return state-\/>drain\_queue();}
\DoxyCodeLine{77                               \});}
\DoxyCodeLine{78         \}}
\DoxyCodeLine{79     \}}
\DoxyCodeLine{80 }
\DoxyCodeLine{81     \textcolor{keyword}{template}<\textcolor{keyword}{typename} TT>}
\DoxyCodeLine{82     std::optional<schedulers::time\_point> emplace\_safe(TT\&\& item)}
\DoxyCodeLine{83     \{}
\DoxyCodeLine{84         std::lock\_guard            lock\{m\_mutex\};}
\DoxyCodeLine{85         \textcolor{keyword}{const} \textcolor{keyword}{auto} delay = std::is\_same\_v<std::exception\_ptr, std::decay\_t<TT>> ? schedulers::duration\{0\} : m\_delay;}
\DoxyCodeLine{86         m\_queue.emplace(++m\_current\_id, m\_worker.now()+delay, std::forward<TT>(item));}
\DoxyCodeLine{87         \textcolor{keywordflow}{if} (!m\_active \&\& m\_queue.size() == 1)}
\DoxyCodeLine{88         \{}
\DoxyCodeLine{89             m\_active = \textcolor{keyword}{true};}
\DoxyCodeLine{90             \textcolor{keywordflow}{return} m\_queue.top().time;}
\DoxyCodeLine{91         \}}
\DoxyCodeLine{92         \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{93     \}}
\DoxyCodeLine{94 }
\DoxyCodeLine{95     schedulers::optional\_duration drain\_queue()}
\DoxyCodeLine{96     \{}
\DoxyCodeLine{97         \textcolor{keywordflow}{while} (\textcolor{keyword}{true})}
\DoxyCodeLine{98         \{}
\DoxyCodeLine{99             std::unique\_lock lock\{m\_mutex\};}
\DoxyCodeLine{100             \textcolor{keywordflow}{if} (m\_queue.empty())}
\DoxyCodeLine{101             \{}
\DoxyCodeLine{102                 m\_active = \textcolor{keyword}{false};}
\DoxyCodeLine{103                 \textcolor{keywordflow}{return} \{\};}
\DoxyCodeLine{104             \}}
\DoxyCodeLine{105 }
\DoxyCodeLine{106             \textcolor{keyword}{auto}\& top = m\_queue.top();}
\DoxyCodeLine{107             \textcolor{keyword}{const} \textcolor{keyword}{auto} now = m\_worker.now();}
\DoxyCodeLine{108             \textcolor{keywordflow}{if} (top.time > now)}
\DoxyCodeLine{109                 \textcolor{keywordflow}{return} top.time -\/ now;}
\DoxyCodeLine{110 }
\DoxyCodeLine{111             \textcolor{keyword}{auto} item = std::move(top.item);}
\DoxyCodeLine{112             m\_queue.pop();}
\DoxyCodeLine{113             lock.unlock();}
\DoxyCodeLine{114 }
\DoxyCodeLine{115             std::visit(utils::overloaded}
\DoxyCodeLine{116                        \{}
\DoxyCodeLine{117                            [\&](T\&\&                       v) \{ m\_subscriber.on\_next(std::move(v)); \},}
\DoxyCodeLine{118                            [\&](\textcolor{keyword}{const} std::exception\_ptr\& err) \{ m\_subscriber.on\_error(err); \},}
\DoxyCodeLine{119                            [\&](completion) \{ m\_subscriber.on\_completed(); \}}
\DoxyCodeLine{120                        \},}
\DoxyCodeLine{121                        std::move(item));}
\DoxyCodeLine{122         \}}
\DoxyCodeLine{123     \}}
\DoxyCodeLine{124 }
\DoxyCodeLine{125 \textcolor{keyword}{private}:}
\DoxyCodeLine{126     \textcolor{keyword}{struct }emission}
\DoxyCodeLine{127     \{}
\DoxyCodeLine{128         \textcolor{keyword}{template}<\textcolor{keyword}{typename} TT>}
\DoxyCodeLine{129         emission(\textcolor{keywordtype}{size\_t} \textcolor{keywordtype}{id}, schedulers::time\_point time, TT\&\& item)}
\DoxyCodeLine{130             : id\{id\}}
\DoxyCodeLine{131             , time\{std::move(time)\}}
\DoxyCodeLine{132             , item\{std::forward<TT>(item)\} \{\}}
\DoxyCodeLine{133 }
\DoxyCodeLine{134         \textcolor{keywordtype}{size\_t}                                          \textcolor{keywordtype}{id}\{\};}
\DoxyCodeLine{135         schedulers::time\_point                          time\{\};}
\DoxyCodeLine{136         std::variant<T, std::exception\_ptr, completion> item\{\};}
\DoxyCodeLine{137 }
\DoxyCodeLine{138         \textcolor{keywordtype}{bool} operator<(\textcolor{keyword}{const} emission\& other)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} std::tie(time, \textcolor{keywordtype}{id}) >= std::tie(other.time, other.id); \}}
\DoxyCodeLine{139     \};}
\DoxyCodeLine{140 }
\DoxyCodeLine{141     schedulers::duration          m\_delay;}
\DoxyCodeLine{142     Worker                        m\_worker;}
\DoxyCodeLine{143     Subscriber                    m\_subscriber;}
\DoxyCodeLine{144     std::mutex                    m\_mutex\{\};}
\DoxyCodeLine{145     \textcolor{keywordtype}{size\_t}                        m\_current\_id\{\};}
\DoxyCodeLine{146     std::priority\_queue<emission> m\_queue\{\};}
\DoxyCodeLine{147     \textcolor{keywordtype}{bool}                          m\_active\{\};}
\DoxyCodeLine{148 \};}
\DoxyCodeLine{149 }
\DoxyCodeLine{150 }
\DoxyCodeLine{151 \textcolor{keyword}{template}<constra\textcolor{keywordtype}{int}::decayed\_type Type, schedulers::constra\textcolor{keywordtype}{int}::scheduler TScheduler>}
\DoxyCodeLine{152 \textcolor{keyword}{struct }\mbox{\hyperlink{structrpp_1_1details_1_1delay__impl}{delay\_impl}}}
\DoxyCodeLine{153 \{}
\DoxyCodeLine{154     RPP\_NO\_UNIQUE\_ADDRESS TScheduler scheduler;}
\DoxyCodeLine{155     schedulers::duration             delay;}
\DoxyCodeLine{156 }
\DoxyCodeLine{157     \textcolor{keyword}{template}<constra\textcolor{keywordtype}{int}::subscriber\_of\_type<Type> TSub>}
\DoxyCodeLine{158     \textcolor{keyword}{auto} operator()(TSub\&\& subscriber)\textcolor{keyword}{ const}}
\DoxyCodeLine{159 \textcolor{keyword}{    }\{}
\DoxyCodeLine{160         \textcolor{keyword}{auto} worker = scheduler.create\_worker(subscriber.get\_subscription());}
\DoxyCodeLine{161         \textcolor{keyword}{auto} subscription = subscriber.get\_subscription().make\_child();}
\DoxyCodeLine{162 }
\DoxyCodeLine{163         \textcolor{keyword}{using }state\_t = \mbox{\hyperlink{classrpp_1_1details_1_1queue__based__worker}{queue\_based\_worker<Type, std::decay\_t<TSub>}}, std::decay\_t<\textcolor{keyword}{decltype}(worker)>>;}
\DoxyCodeLine{164         \textcolor{keyword}{auto} state = std::make\_shared<state\_t>(delay, std::move(worker), std::forward<TSub>(subscriber));}
\DoxyCodeLine{165 }
\DoxyCodeLine{166         \textcolor{keywordflow}{return} create\_subscriber\_with\_state<Type>(std::move(subscription),}
\DoxyCodeLine{167                                                   \textcolor{keyword}{typename} state\_t::on\_next\{\},}
\DoxyCodeLine{168                                                   \textcolor{keyword}{typename} state\_t::on\_error\{\},}
\DoxyCodeLine{169                                                   \textcolor{keyword}{typename} state\_t::on\_completed\{\},}
\DoxyCodeLine{170                                                   std::move(state));}
\DoxyCodeLine{171     \}}
\DoxyCodeLine{172 \};}
\DoxyCodeLine{173 \} \textcolor{comment}{// namespace rpp::details}}

\end{DoxyCode}
