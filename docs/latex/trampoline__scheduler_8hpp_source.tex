\hypertarget{trampoline__scheduler_8hpp_source}{}\doxysection{trampoline\+\_\+scheduler.\+hpp}
\label{trampoline__scheduler_8hpp_source}\index{src/rpp/rpp/schedulers/trampoline\_scheduler.hpp@{src/rpp/rpp/schedulers/trampoline\_scheduler.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{//                  ReactivePlusPlus library}}
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{//          Copyright Aleksey Loginov 2022 -\/ present.}}
\DoxyCodeLine{4 \textcolor{comment}{//                            TC Wang 2022 -\/ present.}}
\DoxyCodeLine{5 \textcolor{comment}{// Distributed under the Boost Software License, Version 1.0.}}
\DoxyCodeLine{6 \textcolor{comment}{//    (See accompanying file LICENSE\_1\_0.txt or copy at}}
\DoxyCodeLine{7 \textcolor{comment}{//          https://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{8 \textcolor{comment}{//}}
\DoxyCodeLine{9 \textcolor{comment}{// Project home: https://github.com/victimsnino/ReactivePlusPlus}}
\DoxyCodeLine{10 \textcolor{comment}{//}}
\DoxyCodeLine{11 }
\DoxyCodeLine{12 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{13 }
\DoxyCodeLine{14 }
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <rpp/schedulers/fwd.hpp>}                       \textcolor{comment}{// own forwarding}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <rpp/schedulers/details/worker.hpp>}            \textcolor{comment}{// worker}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <rpp/subscriptions/composite\_subscription.hpp>} \textcolor{comment}{// lifetime}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <rpp/schedulers/details/queue\_worker\_state.hpp>}\textcolor{comment}{// state}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#include <rpp/utils/utilities.hpp>}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <rpp/schedulers/details/utils.hpp>}}
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include <concepts>}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include <chrono>}}
\DoxyCodeLine{24 \textcolor{preprocessor}{\#include <functional>}}
\DoxyCodeLine{25 \textcolor{preprocessor}{\#include <thread>}}
\DoxyCodeLine{26 }
\DoxyCodeLine{27 }
\DoxyCodeLine{28 \textcolor{keyword}{namespace }rpp::schedulers}
\DoxyCodeLine{29 \{}
\DoxyCodeLine{38 \textcolor{keyword}{class }\mbox{\hyperlink{classrpp_1_1schedulers_1_1trampoline}{trampoline}} final : \textcolor{keyword}{public} \mbox{\hyperlink{structrpp_1_1schedulers_1_1details_1_1scheduler__tag}{details::scheduler\_tag}}}
\DoxyCodeLine{39 \{}
\DoxyCodeLine{40     \textcolor{keyword}{class }current\_thread\_schedulable;}
\DoxyCodeLine{41     \textcolor{keyword}{class }worker\_strategy;}
\DoxyCodeLine{42 }
\DoxyCodeLine{43     \textcolor{keyword}{using }\mbox{\hyperlink{classrpp_1_1schedulers_1_1schedulable__wrapper}{trampoline\_schedulable}} = \mbox{\hyperlink{classrpp_1_1schedulers_1_1schedulable__wrapper}{schedulable\_wrapper<worker\_strategy>}};}
\DoxyCodeLine{44 }
\DoxyCodeLine{45     \textcolor{keyword}{class }worker\_strategy}
\DoxyCodeLine{46     \{}
\DoxyCodeLine{47     \textcolor{keyword}{public}:}
\DoxyCodeLine{48         \textcolor{keyword}{explicit} worker\_strategy(\textcolor{keyword}{const} \mbox{\hyperlink{classrpp_1_1composite__subscription}{rpp::composite\_subscription}}\& subscription)}
\DoxyCodeLine{49             : m\_sub\{ subscription \} \{\}}
\DoxyCodeLine{50 }
\DoxyCodeLine{51         \textcolor{keywordtype}{void} defer\_at(time\_point time\_point, constraint::schedulable\_fn \textcolor{keyword}{auto}\&\& fn)\textcolor{keyword}{ const}}
\DoxyCodeLine{52 \textcolor{keyword}{        }\{}
\DoxyCodeLine{53             \textcolor{keywordflow}{if} (!m\_sub.is\_subscribed())}
\DoxyCodeLine{54                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{55 }
\DoxyCodeLine{56             \textcolor{keyword}{const} \textcolor{keywordtype}{bool} someone\_owns\_queue = s\_queue.has\_value();}
\DoxyCodeLine{57 }
\DoxyCodeLine{58             \textcolor{keyword}{const} \textcolor{keyword}{auto} drain\_on\_exit =  utils::finally\_action(!someone\_owns\_queue ? \&drain\_queue : +[]\{\});}
\DoxyCodeLine{59 }
\DoxyCodeLine{60             \textcolor{keywordflow}{if} (!someone\_owns\_queue)}
\DoxyCodeLine{61             \{}
\DoxyCodeLine{62                 s\_queue = std::priority\_queue<current\_thread\_schedulable>\{\};}
\DoxyCodeLine{63 }
\DoxyCodeLine{64                 \textcolor{keywordflow}{if} (!details::immediate\_scheduling\_while\_condition(time\_point, fn, m\_sub, []() \{ \textcolor{keywordflow}{return} s\_queue-\/>empty(); \}))}
\DoxyCodeLine{65                     \textcolor{keywordflow}{return};}
\DoxyCodeLine{66 }
\DoxyCodeLine{67                 \textcolor{comment}{// update time to make it more accurate due to we are going to push it to queue}}
\DoxyCodeLine{68                 time\_point = std::max(now(), time\_point);}
\DoxyCodeLine{69             \}}
\DoxyCodeLine{70 }
\DoxyCodeLine{71             defer\_at(time\_point, \mbox{\hyperlink{classrpp_1_1schedulers_1_1schedulable__wrapper}{trampoline\_schedulable}}\{ *\textcolor{keyword}{this}, time\_point, std::forward<decltype(fn)>(fn) \});}
\DoxyCodeLine{72         \}}
\DoxyCodeLine{73 }
\DoxyCodeLine{74         \textcolor{keywordtype}{void} defer\_at(time\_point time\_point, \mbox{\hyperlink{classrpp_1_1schedulers_1_1schedulable__wrapper}{trampoline\_schedulable}}\&\& fn)\textcolor{keyword}{ const}}
\DoxyCodeLine{75 \textcolor{keyword}{        }\{}
\DoxyCodeLine{76             \textcolor{keywordflow}{if} (!m\_sub.is\_subscribed())}
\DoxyCodeLine{77                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{78 }
\DoxyCodeLine{79             s\_queue-\/>emplace(time\_point, std::move(fn), m\_sub);}
\DoxyCodeLine{80         \}}
\DoxyCodeLine{81 }
\DoxyCodeLine{82         \textcolor{keyword}{static} time\_point now() \{ \textcolor{keywordflow}{return} clock\_type::now(); \}}
\DoxyCodeLine{83 }
\DoxyCodeLine{84     \textcolor{keyword}{private}:}
\DoxyCodeLine{85         \mbox{\hyperlink{classrpp_1_1composite__subscription}{rpp::composite\_subscription}} m\_sub;}
\DoxyCodeLine{86     \};}
\DoxyCodeLine{87 }
\DoxyCodeLine{88     \textcolor{keyword}{static} \textcolor{keywordtype}{void} drain\_queue()}
\DoxyCodeLine{89     \{}
\DoxyCodeLine{90         \textcolor{keywordflow}{if} (!s\_queue.has\_value())}
\DoxyCodeLine{91             \textcolor{keywordflow}{return};}
\DoxyCodeLine{92 }
\DoxyCodeLine{93         \textcolor{keyword}{auto}  reset\_at\_final = utils::finally\_action\{ [] \{ s\_queue.reset(); \} \};}
\DoxyCodeLine{94         std::optional<trampoline\_schedulable> function\{\};}
\DoxyCodeLine{95 }
\DoxyCodeLine{96         \textcolor{keywordflow}{while} (!s\_queue-\/>empty())}
\DoxyCodeLine{97         \{}
\DoxyCodeLine{98             \textcolor{keyword}{const} \textcolor{keyword}{auto}\& top = s\_queue-\/>top();}
\DoxyCodeLine{99 }
\DoxyCodeLine{100             wait\_and\_extract\_executable\_if\_subscribed(top, function);}
\DoxyCodeLine{101 }
\DoxyCodeLine{102             \textcolor{comment}{// firstly we need to pop schedulable from queue due to execution of function can add new schedulable}}
\DoxyCodeLine{103             s\_queue-\/>pop();}
\DoxyCodeLine{104 }
\DoxyCodeLine{105             \textcolor{keywordflow}{if} (function)}
\DoxyCodeLine{106                 (*function)();}
\DoxyCodeLine{107 }
\DoxyCodeLine{108             function.reset();}
\DoxyCodeLine{109         \}}
\DoxyCodeLine{110     \}}
\DoxyCodeLine{111 }
\DoxyCodeLine{112     \textcolor{keyword}{static} \textcolor{keywordtype}{void} wait\_and\_extract\_executable\_if\_subscribed(\textcolor{keyword}{const} current\_thread\_schedulable\& schedulable, std::optional<trampoline\_schedulable>\& out)}
\DoxyCodeLine{113     \{}
\DoxyCodeLine{114         \textcolor{keywordflow}{if} (!schedulable.is\_subscribed())}
\DoxyCodeLine{115             \textcolor{keywordflow}{return};}
\DoxyCodeLine{116 }
\DoxyCodeLine{117         \textcolor{comment}{// wait only if needed!}}
\DoxyCodeLine{118         \textcolor{keywordflow}{if} (\textcolor{keyword}{const} \textcolor{keyword}{auto} requested\_time = schedulable.get\_time\_point(); details::s\_last\_sleep\_timepoint < requested\_time)}
\DoxyCodeLine{119         \{}
\DoxyCodeLine{120             std::this\_thread::sleep\_until(requested\_time);}
\DoxyCodeLine{121             details::s\_last\_sleep\_timepoint = requested\_time;}
\DoxyCodeLine{122 }
\DoxyCodeLine{123             \textcolor{keywordflow}{if} (!schedulable.is\_subscribed())}
\DoxyCodeLine{124                 \textcolor{keywordflow}{return};}
\DoxyCodeLine{125         \}}
\DoxyCodeLine{126 }
\DoxyCodeLine{127         out.emplace(std::move(schedulable.extract\_function()));}
\DoxyCodeLine{128     \}}
\DoxyCodeLine{129 }
\DoxyCodeLine{130     \textcolor{keyword}{class }current\_thread\_schedulable : \textcolor{keyword}{public} \mbox{\hyperlink{classrpp_1_1schedulers_1_1details_1_1schedulable}{details::schedulable}}<trampoline\_schedulable>}
\DoxyCodeLine{131     \{}
\DoxyCodeLine{132     \textcolor{keyword}{public}:}
\DoxyCodeLine{133         current\_thread\_schedulable(time\_point                  time\_point,}
\DoxyCodeLine{134                                    std::invocable \textcolor{keyword}{auto}\&\&       fn,}
\DoxyCodeLine{135                                    \mbox{\hyperlink{classrpp_1_1composite__subscription}{rpp::composite\_subscription}} subscription)}
\DoxyCodeLine{136             : schedulable(time\_point, get\_thread\_local\_id(), std::forward<\textcolor{keyword}{decltype}(fn)>(fn))}
\DoxyCodeLine{137             , m\_subscription\{std::move(subscription)\} \{\}}
\DoxyCodeLine{138 }
\DoxyCodeLine{139         \textcolor{keywordtype}{bool} is\_subscribed()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_subscription.is\_subscribed(); \}}
\DoxyCodeLine{140 }
\DoxyCodeLine{141     \textcolor{keyword}{private}:}
\DoxyCodeLine{142         \textcolor{keyword}{static} \textcolor{keywordtype}{size\_t} get\_thread\_local\_id()}
\DoxyCodeLine{143         \{}
\DoxyCodeLine{144             \textcolor{keyword}{static} \textcolor{keyword}{thread\_local} \textcolor{keywordtype}{size\_t} s\_id;}
\DoxyCodeLine{145             \textcolor{keywordflow}{return} s\_id++;}
\DoxyCodeLine{146         \}}
\DoxyCodeLine{147 }
\DoxyCodeLine{148     \textcolor{keyword}{private}:}
\DoxyCodeLine{149         \mbox{\hyperlink{classrpp_1_1composite__subscription}{rpp::composite\_subscription}} m\_subscription\{\};}
\DoxyCodeLine{150     \};}
\DoxyCodeLine{151 }
\DoxyCodeLine{155     \textcolor{keyword}{inline} \textcolor{keyword}{static} \textcolor{keyword}{thread\_local} std::optional<std::priority\_queue<current\_thread\_schedulable>> s\_queue\{\};}
\DoxyCodeLine{156 }
\DoxyCodeLine{157 \textcolor{keyword}{public}:}
\DoxyCodeLine{158     \textcolor{keyword}{static} utils::finally\_action<void (*)()> own\_queue\_and\_drain\_finally\_if\_not\_owned()}
\DoxyCodeLine{159     \{}
\DoxyCodeLine{160         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} someone\_owns\_queue = s\_queue.has\_value();}
\DoxyCodeLine{161 }
\DoxyCodeLine{162         \textcolor{keywordflow}{if} (!someone\_owns\_queue)}
\DoxyCodeLine{163             s\_queue = std::priority\_queue<current\_thread\_schedulable>\{\};}
\DoxyCodeLine{164 }
\DoxyCodeLine{165         \textcolor{keywordflow}{return} \{!someone\_owns\_queue ? \&drain\_queue : +[] \{\}\};}
\DoxyCodeLine{166     \}}
\DoxyCodeLine{167 }
\DoxyCodeLine{168     \textcolor{keyword}{static} \textcolor{keyword}{auto} create\_worker(\textcolor{keyword}{const} \mbox{\hyperlink{classrpp_1_1composite__subscription}{rpp::composite\_subscription}}\& sub = \mbox{\hyperlink{classrpp_1_1composite__subscription}{composite\_subscription}}\{\})}
\DoxyCodeLine{169     \{}
\DoxyCodeLine{170         \textcolor{keywordflow}{return} \mbox{\hyperlink{classrpp_1_1schedulers_1_1worker}{worker<worker\_strategy>}}\{sub\};}
\DoxyCodeLine{171     \}}
\DoxyCodeLine{172 \};}
\DoxyCodeLine{173 \} \textcolor{comment}{// namespace rpp::schedulers}}

\end{DoxyCode}
