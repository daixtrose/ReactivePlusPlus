\hypertarget{debounce_8hpp_source}{}\doxysection{debounce.\+hpp}
\label{debounce_8hpp_source}\index{src/rpp/rpp/operators/debounce.hpp@{src/rpp/rpp/operators/debounce.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{//                  ReactivePlusPlus library}}
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{//          Copyright Aleksey Loginov 2022 -\/ present.}}
\DoxyCodeLine{4 \textcolor{comment}{// Distributed under the Boost Software License, Version 1.0.}}
\DoxyCodeLine{5 \textcolor{comment}{//    (See accompanying file LICENSE\_1\_0.txt or copy at}}
\DoxyCodeLine{6 \textcolor{comment}{//          https://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{7 \textcolor{comment}{//}}
\DoxyCodeLine{8 \textcolor{comment}{// Project home: https://github.com/victimsnino/ReactivePlusPlus}}
\DoxyCodeLine{9 \textcolor{comment}{//}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <rpp/operators/lift.hpp>}          \textcolor{comment}{// required due to operator uses lift}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <rpp/operators/details/early\_unsubscribe.hpp>}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <rpp/operators/details/serialized\_subscriber.hpp>}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <rpp/operators/details/subscriber\_with\_state.hpp>}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <rpp/operators/fwd/debounce.hpp>}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <rpp/subscribers/constraints.hpp>}}
\DoxyCodeLine{19 }
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <rpp/utils/spinlock.hpp>}}
\DoxyCodeLine{21 }
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include <type\_traits>}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#include <variant>}}
\DoxyCodeLine{24 }
\DoxyCodeLine{25 IMPLEMENTATION\_FILE(debounce\_tag);}
\DoxyCodeLine{26 }
\DoxyCodeLine{27 \textcolor{keyword}{namespace }rpp::details}
\DoxyCodeLine{28 \{}
\DoxyCodeLine{29 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Scheduler>}
\DoxyCodeLine{30 \textcolor{keyword}{class }\mbox{\hyperlink{classrpp_1_1details_1_1debounce__state}{debounce\_state}} : \textcolor{keyword}{public} \mbox{\hyperlink{structrpp_1_1details_1_1early__unsubscribe__state}{early\_unsubscribe\_state}}}
\DoxyCodeLine{31 \{}
\DoxyCodeLine{32 \textcolor{keyword}{public}:}
\DoxyCodeLine{33     \mbox{\hyperlink{classrpp_1_1details_1_1debounce__state}{debounce\_state}}(schedulers::duration period, \textcolor{keyword}{const} Scheduler\& scheduler, \textcolor{keyword}{const} \mbox{\hyperlink{classrpp_1_1composite__subscription}{composite\_subscription}}\& subscription\_of\_subscriber)}
\DoxyCodeLine{34         : \mbox{\hyperlink{structrpp_1_1details_1_1early__unsubscribe__state}{early\_unsubscribe\_state}}(subscription\_of\_subscriber)}
\DoxyCodeLine{35         , m\_period\{period\}}
\DoxyCodeLine{36         , m\_worker\{scheduler.create\_worker(children\_subscriptions)\} \{\}}
\DoxyCodeLine{37 }
\DoxyCodeLine{38     std::optional<schedulers::time\_point> emplace\_safe(\textcolor{keyword}{auto}\&\& v)}
\DoxyCodeLine{39     \{}
\DoxyCodeLine{40         std::lock\_guard lock\{m\_mutex\};}
\DoxyCodeLine{41         m\_value\_to\_be\_emitted.emplace(std::forward<\textcolor{keyword}{decltype}(v)>(v));}
\DoxyCodeLine{42         \textcolor{keyword}{const} \textcolor{keywordtype}{bool} need\_to\_scheduled        = !m\_time\_when\_value\_should\_be\_emitted.has\_value() || !m\_value\_to\_be\_emitted.has\_value();}
\DoxyCodeLine{43         m\_time\_when\_value\_should\_be\_emitted = m\_worker.now() + m\_period;}
\DoxyCodeLine{44         \textcolor{keywordflow}{return} need\_to\_scheduled ? m\_time\_when\_value\_should\_be\_emitted : std::optional<schedulers::time\_point>\{\};}
\DoxyCodeLine{45     \}}
\DoxyCodeLine{46 }
\DoxyCodeLine{47     std::variant<std::monostate, T, schedulers::duration> extract\_value\_or\_time()}
\DoxyCodeLine{48     \{}
\DoxyCodeLine{49         std::lock\_guard lock\{m\_mutex\};}
\DoxyCodeLine{50         \textcolor{keywordflow}{if} (!m\_time\_when\_value\_should\_be\_emitted.has\_value() || !m\_value\_to\_be\_emitted.has\_value())}
\DoxyCodeLine{51             \textcolor{keywordflow}{return} std::monostate\{\};}
\DoxyCodeLine{52 }
\DoxyCodeLine{53         \textcolor{keyword}{const} \textcolor{keyword}{auto} now = m\_worker.now();}
\DoxyCodeLine{54         \textcolor{keywordflow}{if} (m\_time\_when\_value\_should\_be\_emitted > now)}
\DoxyCodeLine{55             \textcolor{keywordflow}{return} m\_time\_when\_value\_should\_be\_emitted.value() -\/ now;}
\DoxyCodeLine{56 }
\DoxyCodeLine{57         m\_time\_when\_value\_should\_be\_emitted.reset();}
\DoxyCodeLine{58         \textcolor{keyword}{auto} v = std::move(m\_value\_to\_be\_emitted).value();}
\DoxyCodeLine{59         m\_value\_to\_be\_emitted.reset();}
\DoxyCodeLine{60         \textcolor{keywordflow}{return} v;}
\DoxyCodeLine{61     \}}
\DoxyCodeLine{62 }
\DoxyCodeLine{63     std::optional<T> extract\_value()}
\DoxyCodeLine{64     \{}
\DoxyCodeLine{65         std::lock\_guard  lock\{m\_mutex\};}
\DoxyCodeLine{66         std::optional<T> res\{\};}
\DoxyCodeLine{67         m\_value\_to\_be\_emitted.swap(res);}
\DoxyCodeLine{68         \textcolor{keywordflow}{return} res;}
\DoxyCodeLine{69     \}}
\DoxyCodeLine{70 }
\DoxyCodeLine{71     \textcolor{keyword}{using }Worker = \textcolor{keyword}{decltype}(std::declval<Scheduler>().create\_worker(std::declval<composite\_subscription>()));}
\DoxyCodeLine{72     \textcolor{keyword}{const} Worker\& get\_worker()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} m\_worker; \}}
\DoxyCodeLine{73 }
\DoxyCodeLine{74 \textcolor{keyword}{private}:}
\DoxyCodeLine{75     schedulers::duration                  m\_period;}
\DoxyCodeLine{76     Worker                                m\_worker;}
\DoxyCodeLine{77     std::mutex                            m\_mutex\{\};}
\DoxyCodeLine{78     std::optional<schedulers::time\_point> m\_time\_when\_value\_should\_be\_emitted\{\};}
\DoxyCodeLine{79     std::optional<T>                      m\_value\_to\_be\_emitted\{\};}
\DoxyCodeLine{80 \};}
\DoxyCodeLine{81 }
\DoxyCodeLine{82 \textcolor{keyword}{struct }\mbox{\hyperlink{structrpp_1_1details_1_1debounce__on__next}{debounce\_on\_next}}}
\DoxyCodeLine{83 \{}
\DoxyCodeLine{84     \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{85     \textcolor{keywordtype}{void} operator()(Value\&\& v, \textcolor{keyword}{const} \textcolor{keyword}{auto}\& state\_ptr)\textcolor{keyword}{ const}}
\DoxyCodeLine{86 \textcolor{keyword}{    }\{}
\DoxyCodeLine{87         \textcolor{keywordflow}{if} (\textcolor{keyword}{const} \textcolor{keyword}{auto} time\_to\_schedule = state\_ptr-\/>emplace\_safe(std::forward<Value>(v)))}
\DoxyCodeLine{88         \{}
\DoxyCodeLine{89             state\_ptr-\/>get\_worker().schedule(time\_to\_schedule.value(),}
\DoxyCodeLine{90                                              [state\_ptr]() mutable -\/> schedulers::optional\_duration}
\DoxyCodeLine{91                                              \{}
\DoxyCodeLine{92                                                  auto value\_or\_duration = state\_ptr-\/>extract\_value\_or\_time();}
\DoxyCodeLine{93                                                  if (auto* duration = std::get\_if<schedulers::duration>(\&value\_or\_duration))}
\DoxyCodeLine{94                                                      return *duration;}
\DoxyCodeLine{95 }
\DoxyCodeLine{96                                                  if (auto* value = std::get\_if<std::decay\_t<Value>>(\&value\_or\_duration))}
\DoxyCodeLine{97                                                      state\_ptr-\/>subscriber.on\_next(std::move(*value));}
\DoxyCodeLine{98 }
\DoxyCodeLine{99                                                  return std::nullopt;}
\DoxyCodeLine{100                                              \});}
\DoxyCodeLine{101         \}}
\DoxyCodeLine{102     \}}
\DoxyCodeLine{103 \};}
\DoxyCodeLine{104 }
\DoxyCodeLine{105 \textcolor{keyword}{struct }\mbox{\hyperlink{structrpp_1_1details_1_1debounce__on__error}{debounce\_on\_error}}}
\DoxyCodeLine{106 \{}
\DoxyCodeLine{107     \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} std::exception\_ptr\& err, \textcolor{keyword}{const} \textcolor{keyword}{auto}\& state)\textcolor{keyword}{ const}}
\DoxyCodeLine{108 \textcolor{keyword}{    }\{}
\DoxyCodeLine{109         state-\/>children\_subscriptions.unsubscribe();}
\DoxyCodeLine{110         state-\/>subscriber.on\_error(err);}
\DoxyCodeLine{111     \}}
\DoxyCodeLine{112 \};}
\DoxyCodeLine{113 }
\DoxyCodeLine{114 \textcolor{keyword}{struct }\mbox{\hyperlink{structrpp_1_1details_1_1debounce__on__completed}{debounce\_on\_completed}}}
\DoxyCodeLine{115 \{}
\DoxyCodeLine{116     \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} \textcolor{keyword}{auto}\& state\_ptr)\textcolor{keyword}{ const}}
\DoxyCodeLine{117 \textcolor{keyword}{    }\{}
\DoxyCodeLine{118         state\_ptr-\/>children\_subscriptions.unsubscribe();}
\DoxyCodeLine{119 }
\DoxyCodeLine{120         \textcolor{keywordflow}{if} (\textcolor{keyword}{auto} v = state\_ptr-\/>extract\_value())}
\DoxyCodeLine{121             state\_ptr-\/>subscriber.on\_next(std::move(v.value()));}
\DoxyCodeLine{122 }
\DoxyCodeLine{123         state\_ptr-\/>subscriber.on\_completed();}
\DoxyCodeLine{124     \}}
\DoxyCodeLine{125 \};}
\DoxyCodeLine{126 }
\DoxyCodeLine{127 \textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keyword}{typename} Scheduler, \textcolor{keyword}{typename} TSub>}
\DoxyCodeLine{128 \textcolor{keyword}{struct }\mbox{\hyperlink{structrpp_1_1details_1_1debounce__state__with__serialized__spinlock}{debounce\_state\_with\_serialized\_spinlock}} : \mbox{\hyperlink{classrpp_1_1details_1_1debounce__state}{debounce\_state}}<T, Scheduler>}
\DoxyCodeLine{129 \{}
\DoxyCodeLine{130     \mbox{\hyperlink{structrpp_1_1details_1_1debounce__state__with__serialized__spinlock}{debounce\_state\_with\_serialized\_spinlock}}(\textcolor{keyword}{auto}\&\&                        sub,}
\DoxyCodeLine{131                                             schedulers::duration          period,}
\DoxyCodeLine{132                                             \textcolor{keyword}{const} Scheduler\&              scheduler)}
\DoxyCodeLine{133         : \mbox{\hyperlink{classrpp_1_1details_1_1debounce__state}{debounce\_state<T, Scheduler>}}\{std::move(period), scheduler, sub.get\_subscription()\}}
\DoxyCodeLine{134         , subscriber(make\_serialized\_subscriber(std::forward<\textcolor{keyword}{decltype}(sub)>(sub), std::ref(spinlock))) \{\}}
\DoxyCodeLine{135 }
\DoxyCodeLine{136     \textcolor{comment}{// spinlock because most part of time there is only one thread would be active}}
\DoxyCodeLine{137     utils::spinlock spinlock\{\};}
\DoxyCodeLine{138 }
\DoxyCodeLine{139     \textcolor{keyword}{using }InnerSub = \textcolor{keyword}{decltype}(make\_serialized\_subscriber(std::declval<TSub>(), std::declval<std::reference\_wrapper<utils::spinlock>>()));}
\DoxyCodeLine{140     InnerSub subscriber;}
\DoxyCodeLine{141 \};}
\DoxyCodeLine{142 }
\DoxyCodeLine{143 \textcolor{keyword}{template}<constra\textcolor{keywordtype}{int}::decayed\_type Type,schedulers::constra\textcolor{keywordtype}{int}::scheduler TScheduler>}
\DoxyCodeLine{144 \textcolor{keyword}{struct }\mbox{\hyperlink{structrpp_1_1details_1_1debounce__impl}{debounce\_impl}}}
\DoxyCodeLine{145 \{}
\DoxyCodeLine{146     schedulers::duration period;}
\DoxyCodeLine{147     TScheduler           scheduler;}
\DoxyCodeLine{148 }
\DoxyCodeLine{149     \textcolor{keyword}{template}<constra\textcolor{keywordtype}{int}::subscriber\_of\_type<Type> TSub>}
\DoxyCodeLine{150     \textcolor{keyword}{auto} operator()(TSub\&\& in\_subscriber)\textcolor{keyword}{ const}}
\DoxyCodeLine{151 \textcolor{keyword}{    }\{}
\DoxyCodeLine{152         \textcolor{keyword}{auto} state = std::make\_shared<debounce\_state\_with\_serialized\_spinlock<Type, TScheduler, std::decay\_t<TSub>>>(std::forward<TSub>(in\_subscriber), period, scheduler);}
\DoxyCodeLine{153 }
\DoxyCodeLine{154         \textcolor{keywordflow}{return} create\_subscriber\_with\_state<Type>(state-\/>children\_subscriptions,}
\DoxyCodeLine{155                                                   \mbox{\hyperlink{structrpp_1_1details_1_1debounce__on__next}{debounce\_on\_next}}\{\},}
\DoxyCodeLine{156                                                   \mbox{\hyperlink{structrpp_1_1details_1_1debounce__on__error}{debounce\_on\_error}}\{\},}
\DoxyCodeLine{157                                                   \mbox{\hyperlink{structrpp_1_1details_1_1debounce__on__completed}{debounce\_on\_completed}}\{\},}
\DoxyCodeLine{158                                                   std::move(state));}
\DoxyCodeLine{159     \}}
\DoxyCodeLine{160 \};}
\DoxyCodeLine{161 \} \textcolor{comment}{// namespace rpp::details}}

\end{DoxyCode}
