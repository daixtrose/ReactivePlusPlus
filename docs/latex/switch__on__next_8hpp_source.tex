\hypertarget{switch__on__next_8hpp_source}{}\doxysection{switch\+\_\+on\+\_\+next.\+hpp}
\label{switch__on__next_8hpp_source}\index{src/rpp/rpp/operators/switch\_on\_next.hpp@{src/rpp/rpp/operators/switch\_on\_next.hpp}}

\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{//                  ReactivePlusPlus library}}
\DoxyCodeLine{2 \textcolor{comment}{//}}
\DoxyCodeLine{3 \textcolor{comment}{//          Copyright Aleksey Loginov 2022 -\/ present.}}
\DoxyCodeLine{4 \textcolor{comment}{// Distributed under the Boost Software License, Version 1.0.}}
\DoxyCodeLine{5 \textcolor{comment}{//    (See accompanying file LICENSE\_1\_0.txt or copy at}}
\DoxyCodeLine{6 \textcolor{comment}{//          https://www.boost.org/LICENSE\_1\_0.txt)}}
\DoxyCodeLine{7 \textcolor{comment}{//}}
\DoxyCodeLine{8 \textcolor{comment}{// Project home: https://github.com/victimsnino/ReactivePlusPlus}}
\DoxyCodeLine{9 \textcolor{comment}{//}}
\DoxyCodeLine{10 }
\DoxyCodeLine{11 \textcolor{preprocessor}{\#pragma once}}
\DoxyCodeLine{12 }
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include <rpp/operators/lift.hpp>}                          \textcolor{comment}{// required due to operator uses lift}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include <rpp/operators/merge.hpp>}}
\DoxyCodeLine{15 \textcolor{preprocessor}{\#include <rpp/operators/fwd/switch\_on\_next.hpp>}}
\DoxyCodeLine{16 \textcolor{preprocessor}{\#include <rpp/subscribers/constraints.hpp>}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#include <rpp/utils/functors.hpp>}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#include <rpp/utils/spinlock.hpp>}}
\DoxyCodeLine{19 }
\DoxyCodeLine{20 }
\DoxyCodeLine{21 \textcolor{preprocessor}{\#include <atomic>}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#include <memory>}}
\DoxyCodeLine{23 }
\DoxyCodeLine{24 IMPLEMENTATION\_FILE(switch\_on\_next\_tag);}
\DoxyCodeLine{25 }
\DoxyCodeLine{26 \textcolor{keyword}{namespace }rpp::details}
\DoxyCodeLine{27 \{}
\DoxyCodeLine{28 \textcolor{keyword}{struct }\mbox{\hyperlink{structrpp_1_1details_1_1switch__on__next__state}{switch\_on\_next\_state}} : \textcolor{keyword}{public} \mbox{\hyperlink{structrpp_1_1details_1_1merge__state}{merge\_state}}}
\DoxyCodeLine{29 \{}
\DoxyCodeLine{30     \textcolor{keyword}{using }merge\_state::merge\_state;}
\DoxyCodeLine{31     }
\DoxyCodeLine{32     \mbox{\hyperlink{classrpp_1_1composite__subscription}{composite\_subscription}} current\_inner\_observable = rpp::composite\_subscription::empty();}
\DoxyCodeLine{33 \};}
\DoxyCodeLine{34 }
\DoxyCodeLine{35 \textcolor{keyword}{struct }\mbox{\hyperlink{structrpp_1_1details_1_1switch__on__next__on__completed__inner}{switch\_on\_next\_on\_completed\_inner}}}
\DoxyCodeLine{36 \{}
\DoxyCodeLine{37     \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} constraint::subscriber \textcolor{keyword}{auto}\&           sub,}
\DoxyCodeLine{38                     \textcolor{keyword}{const} std::shared\_ptr<switch\_on\_next\_state>\& state)\textcolor{keyword}{ const}}
\DoxyCodeLine{39 \textcolor{keyword}{    }\{}
\DoxyCodeLine{40         \textcolor{comment}{// 1 because decrement happens in composite\_subscription\_callback}}
\DoxyCodeLine{41         \textcolor{keywordflow}{if} (state-\/>count\_of\_on\_completed\_needed.load(std::memory\_order::acquire) == 1)}
\DoxyCodeLine{42             sub.on\_completed();}
\DoxyCodeLine{43     \}}
\DoxyCodeLine{44 \};}
\DoxyCodeLine{45 }
\DoxyCodeLine{46 \textcolor{keyword}{using }switch\_on\_next\_on\_next\_inner = merge\_forwarding\_on\_next;}
\DoxyCodeLine{47 \textcolor{keyword}{using }\mbox{\hyperlink{structrpp_1_1details_1_1early__unsubscribe__on__error}{switch\_on\_next\_on\_error}}      = \mbox{\hyperlink{structrpp_1_1details_1_1early__unsubscribe__on__error}{merge\_on\_error}};}
\DoxyCodeLine{48 }
\DoxyCodeLine{49 \textcolor{keyword}{struct }\mbox{\hyperlink{structrpp_1_1details_1_1switch__on__next__on__next}{switch\_on\_next\_on\_next}}}
\DoxyCodeLine{50 \{}
\DoxyCodeLine{51     \textcolor{keyword}{template}<constra\textcolor{keywordtype}{int}::observable TObs>}
\DoxyCodeLine{52     \textcolor{keywordtype}{void} operator()(\textcolor{keyword}{const} TObs\&                                  new\_observable,}
\DoxyCodeLine{53                     \textcolor{keyword}{const} constraint::subscriber \textcolor{keyword}{auto}\&           sub,}
\DoxyCodeLine{54                     \textcolor{keyword}{const} std::shared\_ptr<switch\_on\_next\_state>\& state)\textcolor{keyword}{ const}}
\DoxyCodeLine{55 \textcolor{keyword}{    }\{}
\DoxyCodeLine{56         \textcolor{keyword}{using }ValueType = utils::extract\_observable\_type\_t<TObs>;}
\DoxyCodeLine{57 }
\DoxyCodeLine{58         state-\/>current\_inner\_observable.unsubscribe();}
\DoxyCodeLine{59         state-\/>current\_inner\_observable = state-\/>children\_subscriptions.make\_child();}
\DoxyCodeLine{60         state-\/>current\_inner\_observable.add([state = std::weak\_ptr\{state\}]}
\DoxyCodeLine{61         \{}
\DoxyCodeLine{62             \textcolor{keywordflow}{if} (\textcolor{keyword}{const} \textcolor{keyword}{auto} locked = state.lock())}
\DoxyCodeLine{63                 locked-\/>count\_of\_on\_completed\_needed.fetch\_sub(1, std::memory\_order::relaxed);}
\DoxyCodeLine{64         \});}
\DoxyCodeLine{65 }
\DoxyCodeLine{66         state-\/>count\_of\_on\_completed\_needed.fetch\_add(1, std::memory\_order::relaxed);}
\DoxyCodeLine{67 }
\DoxyCodeLine{68         new\_observable.subscribe(create\_subscriber\_with\_state<ValueType>(state-\/>current\_inner\_observable,}
\DoxyCodeLine{69                                                                          switch\_on\_next\_on\_next\_inner\{\},}
\DoxyCodeLine{70                                                                          \mbox{\hyperlink{structrpp_1_1details_1_1early__unsubscribe__on__error}{switch\_on\_next\_on\_error}}\{\},}
\DoxyCodeLine{71                                                                          \mbox{\hyperlink{structrpp_1_1details_1_1switch__on__next__on__completed__inner}{switch\_on\_next\_on\_completed\_inner}}\{\},}
\DoxyCodeLine{72                                                                          sub,}
\DoxyCodeLine{73                                                                          state));}
\DoxyCodeLine{74     \}}
\DoxyCodeLine{75 \};}
\DoxyCodeLine{76 }
\DoxyCodeLine{77 \textcolor{keyword}{using }\mbox{\hyperlink{structrpp_1_1details_1_1merge__on__completed}{switch\_on\_next\_on\_completed\_outer}} = \mbox{\hyperlink{structrpp_1_1details_1_1merge__on__completed}{merge\_on\_completed}};}
\DoxyCodeLine{78 }
\DoxyCodeLine{79 \textcolor{keyword}{struct }\mbox{\hyperlink{structrpp_1_1details_1_1switch__on__next__state__with__serialized__spinlock}{switch\_on\_next\_state\_with\_serialized\_spinlock}} : \mbox{\hyperlink{structrpp_1_1details_1_1switch__on__next__state}{switch\_on\_next\_state}}}
\DoxyCodeLine{80 \{}
\DoxyCodeLine{81     \textcolor{keyword}{using }switch\_on\_next\_state::switch\_on\_next\_state;}
\DoxyCodeLine{82 }
\DoxyCodeLine{83     \textcolor{comment}{// we can use spinlock there because 99.9\% of time only one ever thread would send values from on\_next (only one active observable), but we have small probability to get error from main observable immediately}}
\DoxyCodeLine{84     utils::spinlock spinlock\{\};}
\DoxyCodeLine{85 \};}
\DoxyCodeLine{86 }
\DoxyCodeLine{87 \textcolor{keyword}{template}<constra\textcolor{keywordtype}{int}::decayed\_type Type>}
\DoxyCodeLine{88 \textcolor{keyword}{struct }\mbox{\hyperlink{structrpp_1_1details_1_1switch__on__next__impl}{switch\_on\_next\_impl}}}
\DoxyCodeLine{89 \{}
\DoxyCodeLine{90     \textcolor{keyword}{using }ValueType = utils::extract\_observable\_type\_t<Type>;}
\DoxyCodeLine{91 }
\DoxyCodeLine{92     \textcolor{keyword}{template}<constra\textcolor{keywordtype}{int}::subscriber\_of\_type<ValueType> TSub>}
\DoxyCodeLine{93     \textcolor{keyword}{auto} operator()(TSub\&\& in\_subscriber)\textcolor{keyword}{ const}}
\DoxyCodeLine{94 \textcolor{keyword}{    }\{}
\DoxyCodeLine{95         \textcolor{keyword}{auto} state = std::make\_shared<switch\_on\_next\_state\_with\_serialized\_spinlock>(in\_subscriber.get\_subscription());}
\DoxyCodeLine{96 }
\DoxyCodeLine{97         \textcolor{comment}{// change subscriber to serialized to avoid manual using of mutex}}
\DoxyCodeLine{98         \textcolor{keyword}{auto} subscriber = make\_serialized\_subscriber(std::forward<TSub>(in\_subscriber), std::shared\_ptr<utils::spinlock>\{state, \&state-\/>spinlock\});}
\DoxyCodeLine{99 }
\DoxyCodeLine{100         state-\/>count\_of\_on\_completed\_needed.fetch\_add(1, std::memory\_order::relaxed);}
\DoxyCodeLine{101 }
\DoxyCodeLine{102         \textcolor{keyword}{auto} subscription = state-\/>children\_subscriptions.make\_child();}
\DoxyCodeLine{103         \textcolor{keywordflow}{return} create\_subscriber\_with\_state<Type>(std::move(subscription),}
\DoxyCodeLine{104                                                   \mbox{\hyperlink{structrpp_1_1details_1_1switch__on__next__on__next}{switch\_on\_next\_on\_next}}\{\},}
\DoxyCodeLine{105                                                   \mbox{\hyperlink{structrpp_1_1details_1_1early__unsubscribe__on__error}{switch\_on\_next\_on\_error}}\{\},}
\DoxyCodeLine{106                                                   \mbox{\hyperlink{structrpp_1_1details_1_1merge__on__completed}{switch\_on\_next\_on\_completed\_outer}}\{\},}
\DoxyCodeLine{107                                                   std::move(subscriber),}
\DoxyCodeLine{108                                                   std::move(state));}
\DoxyCodeLine{109     \}}
\DoxyCodeLine{110 \};}
\DoxyCodeLine{111 \} \textcolor{comment}{// namespace rpp::details}}

\end{DoxyCode}
