\hypertarget{md_docs_2_exception_01_guarantee_autotoc_md6}{}\doxysection{Overview}\label{md_docs_2_exception_01_guarantee_autotoc_md6}
In non-\/reactive programming functions/modules throws exception in case of something invalid. As a result, user can catch it and handle it somehow while internal state of objects can be in some state (invalid/untouched/partly valid) and etc.

In reactive programming there is another way of exception mechanism\+: throwing exception as is from original place is useless. Notification about \char`\"{}something goes wrong\char`\"{} need to receive observer/subscriber, not owner of callstack. As a result, ANY exception obtained during emitting items and etc WOULD be delivered to subscriber/observer via {\ttfamily on\+\_\+error} function and then unsubscribe happens. As a result, no any raw exceptions would be throws during using RPP. In case of emitting {\ttfamily on\+\_\+error} whole internal state of observable keeps valid but it doesn\textquotesingle{}t matter -\/ whole chain would be destroyed due to {\ttfamily on\+\_\+error} forces unsubscribe. Reactive catching mechanisms like {\ttfamily catch} or {\ttfamily retry} {\bfseries{re-\/subscribes}} on observable. it means, that new chain with new states would be created, not re-\/used existing one. 