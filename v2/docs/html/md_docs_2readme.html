<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ReactivePlusPlus: User Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ReactivePlusPlus
   </div>
   <div id="projectbrief">One more implementation of ReactiveX approach in C++ with care about performance and templates in mind</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_2readme.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">User Guide</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a> </p>
<h1><a class="anchor" id="autotoc_md1"></a>
Introduction</h1>
<h2><a class="anchor" id="autotoc_md2"></a>
What is Reactive Programming?</h2>
<p><b>Reactive programming</b> is a <em>design paradigm</em> that focuses on building applications that can efficiently respond to asynchronous <b>events</b>.</p>
<p>Actually, any application or function has two core parts: input and output. Input/output can even be empty:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Input/output itself can be split into the following two types:</p>
<ul>
<li><b>Static</b> - Your application or function just accepts such an input and handles it somehow. For example, arguments from the command line or arguments of your function:</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> sum(<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) { <span class="keywordflow">return</span> a + b; }</div>
</div><!-- fragment --><ul>
<li><b>Distributed in time</b> - Your application or function doesn't know <b>when</b> input (or parts of input) will arrive, but knows <b>what</b> to do when it happens:</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">   <span class="keywordflow">while</span>(<span class="keyword">true</span>)</div>
<div class="line">   {</div>
<div class="line">       <span class="keyword">auto</span> ch = ::getchar();</div>
<div class="line">       std::cout &lt;&lt; <span class="stringliteral">&quot;Obtained char &quot;</span> &lt;&lt; ch &lt;&lt; std::endl;</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p>When dealing with input that is <b>distributed in time</b>, there are two ways to handle it:</p>
<ul>
<li><b>Pulling</b> - You decide <b>when</b> you need extra data (e.g., to get something, request, iterate, etc.) and you are simply <b>checking/requesting</b> some data. In most cases, this is a blocking operation where you request data and wait for it to be available or periodically check its current status. For example, if you like a blog with non-periodical posts, you may check it daily for new posts manually.</li>
<li><b>Pushing</b> - You decide <b>once</b> that you are interested in a source of data, notify this source somehow (e.g., register, subscribe, etc.), and <b>react</b> when new data <b>becomes available</b> to you. For example, you might <b>subscribe</b> to a blog and <b>react</b> to new posts only after receiving a notification on your smartphone, rather than manually checking for updates.</li>
</ul>
<p>Reactive programming is a powerful way to handle input that is distributed in time. Instead of constantly polling for updates or waiting for input to arrive, reactive programming allows you to register callbacks to be executed when the input becomes available.</p>
<p>See <a href="https://reactivex.io/intro.html">https://reactivex.io/intro.html</a> for more details.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Core concepts of Reactive Programming</h2>
<p>In short, Reactive Programming can be described as follows:</p>
<ul>
<li>An <b>Observer</b> subscribes to an <b>Observable</b>.</li>
<li>The <b>Observable</b> automatically notifies its subscribed <b>Observers</b> of any new events/emissions. <b>Observable</b> could invoke next <b>observer</b>'s method:<ul>
<li><b>on_next(T)</b> - notifies about new event/emission</li>
<li><b>on_error(std::exception_ptr)</b> - notified about error during work. It is termination event (no more calls from this observable should be expected)</li>
<li><b>on_completed()</b> - notified about successful completion.It is termination event (no more calls from this observable should be expected)</li>
</ul>
</li>
<li>During subscription, the <b>Observable</b> can return a <b>Disposable</b> (== subscription), which gives the ability to track and dispose of the subscription.</li>
</ul>
<p>For example:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rpp/rpp.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    rpp::source::create&lt;int&gt;([](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; observer)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">while</span> (<span class="keyword">true</span>)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordtype">char</span> ch = ::getchar();</div>
<div class="line">            <span class="keywordflow">if</span> (!::isdigit(ch)) </div>
<div class="line">            {</div>
<div class="line">              observer.on_error(std::make_exception_ptr(std::runtime_error{<span class="stringliteral">&quot;Invalid symbol&quot;</span>}));</div>
<div class="line">              <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordtype">int</span> digit = ch - <span class="charliteral">&#39;0&#39;</span>;</div>
<div class="line">            <span class="keywordflow">if</span> (digit == 0)</div>
<div class="line">            {</div>
<div class="line">                observer.on_completed();</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">            observer.on_next(digit);</div>
<div class="line">        }</div>
<div class="line">    })</div>
<div class="line">    .<a class="code hl_function" href="group__utility__operators.html#ga149309d4b2e0f1201f1ab42597ace8ac">subscribe</a>([](<span class="keywordtype">int</span> val)</div>
<div class="line">               {</div>
<div class="line">                   std::cout &lt;&lt; <span class="stringliteral">&quot;obtained val &quot;</span> &lt;&lt; val &lt;&lt; std::endl;</div>
<div class="line">               },</div>
<div class="line">                [](std::exception_ptr err)</div>
<div class="line">                {</div>
<div class="line">                   std::cout &lt;&lt; <span class="stringliteral">&quot;obtained error &quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                },</div>
<div class="line">               []()</div>
<div class="line">               {</div>
<div class="line">                   std::cout &lt;&lt; <span class="stringliteral">&quot;Completed&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">               });</div>
<div class="line">    <span class="comment">// input: 123456d</span></div>
<div class="line">    <span class="comment">// output:  obtained val 1</span></div>
<div class="line">    <span class="comment">//          obtained val 2</span></div>
<div class="line">    <span class="comment">//          obtained val 3</span></div>
<div class="line">    <span class="comment">//          obtained val 4</span></div>
<div class="line">    <span class="comment">//          obtained val 5</span></div>
<div class="line">    <span class="comment">//          obtained val 6</span></div>
<div class="line">    <span class="comment">//          obtained error</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// input: 1230</span></div>
<div class="line">    <span class="comment">// output: obtained val 1</span></div>
<div class="line">    <span class="comment">//         obtained val 2</span></div>
<div class="line">    <span class="comment">//         obtained val 3</span></div>
<div class="line">    <span class="comment">//         Completed</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__utility__operators_html_ga149309d4b2e0f1201f1ab42597ace8ac"><div class="ttname"><a href="group__utility__operators.html#ga149309d4b2e0f1201f1ab42597ace8ac">rpp::operators::subscribe</a></div><div class="ttdeci">auto subscribe(observer&lt; Type, ObserverStrategy &gt; &amp;&amp;observer)</div><div class="ttdoc">Subscribes passed observer to emissions from this observable.</div><div class="ttdef"><b>Definition</b> subscribe.hpp:151</div></div>
</div><!-- fragment --><p>There we are creating observable that emits digits from console input:In case of user promted something else it is <b>error</b> for our observable (it is expected to emit ONLY digits). In this case we are notifying observer about it and just stopping. When user prompts <code>0</code>, it means "end of observable".</p>
<p>See <a href="https://reactivex.io/documentation/observable.html">https://reactivex.io/documentation/observable.html</a> for more details.</p>
<p>In such an way it is not powerful enough, so Reactive Programming provides a list of <b>operators</b>.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Operators</h2>
<p><b>Operators</b> are ways to modify the <b>Observable</b>'s emissions to adapt values to the <b>Observer</b>.</p>
<p>For example, we can create observable which: get chars from console input, do it till ‘0’ char, get only letters and send to observer this letters as UPPER. With operators it is pretty simple to do it in correct way:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;rpp/rpp.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_function" href="group__creational__operators.html#ga519523490394660d7e8c46d2d5612f75">rpp::source::from_callable</a>(&amp;::getchar)</div>
<div class="line">    | <a class="code hl_function" href="group__utility__operators.html#ga41ef49dc75a3eadb0eb3fda7c3692c40">rpp::operators::repeat</a>()</div>
<div class="line">    | <a class="code hl_function" href="group__conditional__operators.html#gad40c85eab44ed3bcb4649137088ebd68">rpp::operators::take_while</a>([](<span class="keywordtype">char</span> v) { <span class="keywordflow">return</span> v != <span class="charliteral">&#39;0&#39;</span>; })</div>
<div class="line">    | <a class="code hl_function" href="group__filtering__operators.html#ga3ddeadf25b1cb3105f628ea11dc3a28a">rpp::operators::filter</a>(std::not_fn(&amp;::isdigit))</div>
<div class="line">    | <a class="code hl_function" href="group__transforming__operators.html#gaa1e52694559ad873f33b62ada4c45675">rpp::operators::map</a>(&amp;::toupper)</div>
<div class="line">    | <a class="code hl_function" href="group__utility__operators.html#ga149309d4b2e0f1201f1ab42597ace8ac">rpp::operators::subscribe</a>([](<span class="keywordtype">char</span> v) { std::cout &lt;&lt; v; });</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// input: 12345qwer5125ttqt0</span></div>
<div class="line">  <span class="comment">// output: QWERTTQT</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="agroup__conditional__operators_html_gad40c85eab44ed3bcb4649137088ebd68"><div class="ttname"><a href="group__conditional__operators.html#gad40c85eab44ed3bcb4649137088ebd68">rpp::operators::take_while</a></div><div class="ttdeci">auto take_while(Fn &amp;&amp;predicate)</div><div class="ttdoc">Sends items from observable while items are satisfy predicate. When condition becomes false -&gt; sends ...</div><div class="ttdef"><b>Definition</b> take_while.hpp:73</div></div>
<div class="ttc" id="agroup__creational__operators_html_ga519523490394660d7e8c46d2d5612f75"><div class="ttname"><a href="group__creational__operators.html#ga519523490394660d7e8c46d2d5612f75">rpp::source::from_callable</a></div><div class="ttdeci">auto from_callable(Callable &amp;&amp;callable)</div><div class="ttdoc">Creates rpp::specific_observable that calls provided callable and emits resulting value of this calla...</div><div class="ttdef"><b>Definition</b> from.hpp:242</div></div>
<div class="ttc" id="agroup__filtering__operators_html_ga3ddeadf25b1cb3105f628ea11dc3a28a"><div class="ttname"><a href="group__filtering__operators.html#ga3ddeadf25b1cb3105f628ea11dc3a28a">rpp::operators::filter</a></div><div class="ttdeci">auto filter(Fn &amp;&amp;predicate)</div><div class="ttdoc">Emit only those items from an Observable that satisfies a provided predicate.</div><div class="ttdef"><b>Definition</b> filter.hpp:74</div></div>
<div class="ttc" id="agroup__transforming__operators_html_gaa1e52694559ad873f33b62ada4c45675"><div class="ttname"><a href="group__transforming__operators.html#gaa1e52694559ad873f33b62ada4c45675">rpp::operators::map</a></div><div class="ttdeci">auto map(Fn &amp;&amp;callable)</div><div class="ttdoc">Transforms the items emitted by an Observable via applying a function to each item and emitting resul...</div><div class="ttdef"><b>Definition</b> map.hpp:77</div></div>
<div class="ttc" id="agroup__utility__operators_html_ga41ef49dc75a3eadb0eb3fda7c3692c40"><div class="ttname"><a href="group__utility__operators.html#ga41ef49dc75a3eadb0eb3fda7c3692c40">rpp::operators::repeat</a></div><div class="ttdeci">auto repeat()</div><div class="ttdoc">Repeats the Observabe's sequence of emissions infinite amount of times via re-subscribing on it durin...</div><div class="ttdef"><b>Definition</b> repeat.hpp:85</div></div>
</div><!-- fragment --><p>You can check documentation for each operator on <a href="https://victimsnino.github.io/ReactivePlusPlus/v2/docs/html/group__rpp.html">API Reference</a> page. Below you can find details about how operator works and how to create your own custom operator in RPP.</p>
<p>See <a href="https://reactivex.io/documentation/operators.html">https://reactivex.io/documentation/operators.html</a> for more details about operators concept.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Schedulers</h2>
<p>Reactive programming becomes even more powerful when observables can operate across multiple threads, rather than being confined to the thread of creation and subscription. This allows for non-blocking, asynchronous operations and provides significant advantages over raw iteration or other pull-based approaches. To enable multithreading in your observables, you can use <b>Schedulers</b>.</p>
<p>By default, an <b>Observable</b> will perform its work in the thread where the <b>subscribe</b> operation occurs. However, you can change this behavior using the <b>subscribe_on</b> operator. This operator forces the observable to perform the <b>subscription</b> and any subsequent work in the specified <b>scheduler</b>.</p>
<p>The <b>observe_on</b> operator specifies the <b>scheduler</b> that will be used for emission during the processing of further operators after <b>observe_on</b>.</p>
<p>A <b>Scheduler</b> is responsible for controlling the type of multithreading behavior (or lack thereof) used in the observable. For example, a <b>scheduler</b> can utilize a new thread, a thread pool, or a raw queue to manage its processing.</p>
<p>Checkout <a href="https://victimsnino.github.io/ReactivePlusPlus/v2/docs/html/group__rpp.html">API Reference</a> to learn more about schedulers in RPP.</p>
<p>See <a href="https://reactivex.io/documentation/scheduler.html">https://reactivex.io/documentation/scheduler.html</a> for more details about scheduler concept.</p>
<h2><a class="anchor" id="autotoc_md6"></a>
Disposable</h2>
<p>In reactive programming, a <b>disposable</b> is an object that represents a resource that needs to be released or disposed of when it is no longer needed. This can include things like file handles, network connections, or any other resource that needs to be cleaned up after use.</p>
<p>The purpose of a disposable is to provide a way to manage resources in a safe and efficient manner. By using disposables, you can ensure that resources are released in a timely manner, preventing memory leaks and other issues that can arise from resource leaks.</p>
<p>In most cases disposables are placed in observers. RPP's observer can use two types of disposables:</p>
<ol type="1">
<li><b>Upstream disposable</b> - This is a disposable that the observable puts into the observer. The upstream disposable keeps some state or callback that should be disposed of when the observer is disposed. This ensures that any resources used by the observable are properly cleaned up when the observer obtains on_error/on_completed or disposed in any other way.</li>
<li><b>External disposable</b> - This is a disposable that allows the observer to be disposed of from outside the observer itself. This can be useful in situations where you need to cancel an ongoing operation or release resources before the observable has completed its work.</li>
</ol>
<h1><a class="anchor" id="autotoc_md7"></a>
Advanced</h1>
<h2><a class="anchor" id="autotoc_md8"></a>
Observable contract</h2>
<p>Reactive programming has <a href="https://reactivex.io/documentation/contract.html">Observable Contract</a>. Please, read it.</p>
<p>This contact has next important part:</p>
<blockquote class="doxtable">
<p>&zwj;Observables must issue notifications to observers serially (not in parallel). They may issue these notifications from different threads, but there must be a formal happens-before relationship between the notifications </p>
</blockquote>
<p>RPP follows this contract and especially this part. It means, that:</p>
<ol type="1">
<li><b>All</b> implemented in <b>RPP operators</b> are <b>following this contract</b>:<br  />
 All built-in RPP observables/operators emit emission serially</li>
<li>Any user-provided callbacks (for operators or observers) can be not thread-safe due to thread-safety of observable is guaranteed. <br  />
 For example: internal logic of <code>take</code> operator doesn't use mutexes or atomics due to underlying observable <b>MUST</b> emit items serially</li>
<li>When you implement your own operator via <code>create</code> be careful to <b>follow this contract</b>!</li>
<li>It is true <b>EXCEPT FOR</b> subjects if they are used manually due to users can use subjects for its own purposes there is potentially place for breaking this concept. Be careful and use synchronized subjects instead if can't guarantee serial emissions!</li>
</ol>
<p>It means, that for example:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> s1 = <a class="code hl_function" href="group__creational__operators.html#gae60bdb9b493443d2786b0eee8bfe17ab">rpp::source::just</a>(1) | <a class="code hl_function" href="group__utility__operators.html#ga41ef49dc75a3eadb0eb3fda7c3692c40">rpp::operators::repeat</a>() | <a class="code hl_function" href="group__utility__operators.html#gace728cfbf71720901cb6f310edabf8b0">rpp::operators::subscribe_on</a>(<a class="code hl_class" href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a>{});</div>
<div class="line"><span class="keyword">auto</span> s2 = <a class="code hl_function" href="group__creational__operators.html#gae60bdb9b493443d2786b0eee8bfe17ab">rpp::source::just</a>(2) | <a class="code hl_function" href="group__utility__operators.html#ga41ef49dc75a3eadb0eb3fda7c3692c40">rpp::operators::repeat</a>() | <a class="code hl_function" href="group__utility__operators.html#gace728cfbf71720901cb6f310edabf8b0">rpp::operators::subscribe_on</a>(<a class="code hl_class" href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a>{});</div>
<div class="line">s1 | <a class="code hl_function" href="group__combining__operators.html#ga063bcb64ac3afbedca8b257d3558f2dd">rpp::operators::merge_with</a>(s2)</div>
<div class="line">   | <a class="code hl_function" href="group__transforming__operators.html#gaa1e52694559ad873f33b62ada4c45675">rpp::operators::map</a>([](<span class="keywordtype">int</span> v)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;enter &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</div>
<div class="line">    std::this_thread::sleep_for(std::chrono::seconds{1});</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;exit &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</div>
<div class="line">    <span class="keywordflow">return</span> v;</div>
<div class="line">  })</div>
<div class="line">  | <a class="code hl_function" href="group__utility__operators.html#ga9df008c11eeff8c9383e56bf36e28ec2">rpp::operators::as_blocking</a>()</div>
<div class="line">  | <a class="code hl_function" href="group__utility__operators.html#ga149309d4b2e0f1201f1ab42597ace8ac">rpp::operators::subscribe</a>([](<span class="keywordtype">int</span>){});</div>
<div class="ttc" id="aclassrpp_1_1schedulers_1_1new__thread_html"><div class="ttname"><a href="classrpp_1_1schedulers_1_1new__thread.html">rpp::schedulers::new_thread</a></div><div class="ttdoc">Scheduler which schedules invoking of schedulables to another thread via queueing tasks with priority...</div><div class="ttdef"><b>Definition</b> new_thread.hpp:31</div></div>
<div class="ttc" id="agroup__combining__operators_html_ga063bcb64ac3afbedca8b257d3558f2dd"><div class="ttname"><a href="group__combining__operators.html#ga063bcb64ac3afbedca8b257d3558f2dd">rpp::operators::merge_with</a></div><div class="ttdeci">auto merge_with(TObservable &amp;&amp;observable, TObservables &amp;&amp;...observables)</div><div class="ttdoc">Combines submissions from current observable with other observables into one.</div><div class="ttdef"><b>Definition</b> merge.hpp:243</div></div>
<div class="ttc" id="agroup__creational__operators_html_gae60bdb9b493443d2786b0eee8bfe17ab"><div class="ttname"><a href="group__creational__operators.html#gae60bdb9b493443d2786b0eee8bfe17ab">rpp::source::just</a></div><div class="ttdeci">auto just(const TScheduler &amp;scheduler, T &amp;&amp;item, Ts &amp;&amp;...items)</div><div class="ttdoc">Creates rpp::observable that emits a particular items and completes.</div><div class="ttdef"><b>Definition</b> from.hpp:195</div></div>
<div class="ttc" id="agroup__utility__operators_html_ga9df008c11eeff8c9383e56bf36e28ec2"><div class="ttname"><a href="group__utility__operators.html#ga9df008c11eeff8c9383e56bf36e28ec2">rpp::operators::as_blocking</a></div><div class="ttdeci">auto as_blocking()</div><div class="ttdoc">Converts rpp::observable to rpp::blocking_observable</div><div class="ttdef"><b>Definition</b> as_blocking.hpp:43</div></div>
<div class="ttc" id="agroup__utility__operators_html_gace728cfbf71720901cb6f310edabf8b0"><div class="ttname"><a href="group__utility__operators.html#gace728cfbf71720901cb6f310edabf8b0">rpp::operators::subscribe_on</a></div><div class="ttdeci">auto subscribe_on(Scheduler &amp;&amp;scheduler)</div><div class="ttdoc">OnSubscribe function for this observable will be scheduled via provided scheduler.</div><div class="ttdef"><b>Definition</b> subscribe_on.hpp:70</div></div>
</div><!-- fragment --><p>will never produce something like</p>
<div class="fragment"><div class="line">enter 1</div>
<div class="line">enter 2</div>
<div class="line">exit 2</div>
<div class="line">exit 1</div>
</div><!-- fragment --><p>only serially</p>
<div class="fragment"><div class="line">enter 1</div>
<div class="line">exit 1</div>
<div class="line">enter 1</div>
<div class="line">exit 1</div>
<div class="line">enter 2</div>
<div class="line">exit 2</div>
<div class="line">enter 2</div>
<div class="line">exit 2</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>
